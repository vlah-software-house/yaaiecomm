// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: discounts.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCoupon = `-- name: CreateCoupon :one
INSERT INTO coupons (
  id, code, discount_id, usage_limit, usage_limit_per_customer,
  usage_count, starts_at, ends_at, is_active, created_at, updated_at
) VALUES ($1, $2, $3, $4, $5, 0, $6, $7, $8, $9, $9)
RETURNING id, code, discount_id, usage_limit, usage_limit_per_customer, usage_count, starts_at, ends_at, is_active, created_at, updated_at
`

type CreateCouponParams struct {
	ID                    uuid.UUID          `json:"id"`
	Code                  string             `json:"code"`
	DiscountID            uuid.UUID          `json:"discount_id"`
	UsageLimit            *int32             `json:"usage_limit"`
	UsageLimitPerCustomer *int32             `json:"usage_limit_per_customer"`
	StartsAt              pgtype.Timestamptz `json:"starts_at"`
	EndsAt                pgtype.Timestamptz `json:"ends_at"`
	IsActive              bool               `json:"is_active"`
	CreatedAt             time.Time          `json:"created_at"`
}

func (q *Queries) CreateCoupon(ctx context.Context, arg CreateCouponParams) (Coupon, error) {
	row := q.db.QueryRow(ctx, createCoupon,
		arg.ID,
		arg.Code,
		arg.DiscountID,
		arg.UsageLimit,
		arg.UsageLimitPerCustomer,
		arg.StartsAt,
		arg.EndsAt,
		arg.IsActive,
		arg.CreatedAt,
	)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.DiscountID,
		&i.UsageLimit,
		&i.UsageLimitPerCustomer,
		&i.UsageCount,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDiscount = `-- name: CreateDiscount :one
INSERT INTO discounts (
  id, name, type, value, scope, minimum_amount, maximum_discount,
  starts_at, ends_at, is_active, priority, stackable, conditions,
  created_at, updated_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $14)
RETURNING id, name, type, value, scope, minimum_amount, maximum_discount, starts_at, ends_at, is_active, priority, stackable, conditions, created_at, updated_at
`

type CreateDiscountParams struct {
	ID              uuid.UUID          `json:"id"`
	Name            string             `json:"name"`
	Type            string             `json:"type"`
	Value           pgtype.Numeric     `json:"value"`
	Scope           string             `json:"scope"`
	MinimumAmount   pgtype.Numeric     `json:"minimum_amount"`
	MaximumDiscount pgtype.Numeric     `json:"maximum_discount"`
	StartsAt        pgtype.Timestamptz `json:"starts_at"`
	EndsAt          pgtype.Timestamptz `json:"ends_at"`
	IsActive        bool               `json:"is_active"`
	Priority        int32              `json:"priority"`
	Stackable       bool               `json:"stackable"`
	Conditions      json.RawMessage    `json:"conditions"`
	CreatedAt       time.Time          `json:"created_at"`
}

func (q *Queries) CreateDiscount(ctx context.Context, arg CreateDiscountParams) (Discount, error) {
	row := q.db.QueryRow(ctx, createDiscount,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Value,
		arg.Scope,
		arg.MinimumAmount,
		arg.MaximumDiscount,
		arg.StartsAt,
		arg.EndsAt,
		arg.IsActive,
		arg.Priority,
		arg.Stackable,
		arg.Conditions,
		arg.CreatedAt,
	)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Value,
		&i.Scope,
		&i.MinimumAmount,
		&i.MaximumDiscount,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsActive,
		&i.Priority,
		&i.Stackable,
		&i.Conditions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCoupon = `-- name: GetCoupon :one
SELECT id, code, discount_id, usage_limit, usage_limit_per_customer, usage_count, starts_at, ends_at, is_active, created_at, updated_at FROM coupons WHERE id = $1
`

func (q *Queries) GetCoupon(ctx context.Context, id uuid.UUID) (Coupon, error) {
	row := q.db.QueryRow(ctx, getCoupon, id)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.DiscountID,
		&i.UsageLimit,
		&i.UsageLimitPerCustomer,
		&i.UsageCount,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCouponByCode = `-- name: GetCouponByCode :one
SELECT id, code, discount_id, usage_limit, usage_limit_per_customer, usage_count, starts_at, ends_at, is_active, created_at, updated_at FROM coupons WHERE code = $1
`

func (q *Queries) GetCouponByCode(ctx context.Context, code string) (Coupon, error) {
	row := q.db.QueryRow(ctx, getCouponByCode, code)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.DiscountID,
		&i.UsageLimit,
		&i.UsageLimitPerCustomer,
		&i.UsageCount,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDiscount = `-- name: GetDiscount :one
SELECT id, name, type, value, scope, minimum_amount, maximum_discount, starts_at, ends_at, is_active, priority, stackable, conditions, created_at, updated_at FROM discounts WHERE id = $1
`

func (q *Queries) GetDiscount(ctx context.Context, id uuid.UUID) (Discount, error) {
	row := q.db.QueryRow(ctx, getDiscount, id)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Value,
		&i.Scope,
		&i.MinimumAmount,
		&i.MaximumDiscount,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsActive,
		&i.Priority,
		&i.Stackable,
		&i.Conditions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementCouponUsage = `-- name: IncrementCouponUsage :exec
UPDATE coupons SET usage_count = usage_count + 1, updated_at = $2 WHERE id = $1
`

type IncrementCouponUsageParams struct {
	ID        uuid.UUID `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) IncrementCouponUsage(ctx context.Context, arg IncrementCouponUsageParams) error {
	_, err := q.db.Exec(ctx, incrementCouponUsage, arg.ID, arg.UpdatedAt)
	return err
}

const listActiveDiscounts = `-- name: ListActiveDiscounts :many
SELECT id, name, type, value, scope, minimum_amount, maximum_discount, starts_at, ends_at, is_active, priority, stackable, conditions, created_at, updated_at FROM discounts
WHERE is_active = true
AND (starts_at IS NULL OR starts_at <= NOW())
AND (ends_at IS NULL OR ends_at > NOW())
ORDER BY priority DESC
`

func (q *Queries) ListActiveDiscounts(ctx context.Context) ([]Discount, error) {
	rows, err := q.db.Query(ctx, listActiveDiscounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Scope,
			&i.MinimumAmount,
			&i.MaximumDiscount,
			&i.StartsAt,
			&i.EndsAt,
			&i.IsActive,
			&i.Priority,
			&i.Stackable,
			&i.Conditions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoupons = `-- name: ListCoupons :many
SELECT c.id, c.code, c.discount_id, c.usage_limit, c.usage_limit_per_customer, c.usage_count, c.starts_at, c.ends_at, c.is_active, c.created_at, c.updated_at, d.name as discount_name FROM coupons c
JOIN discounts d ON d.id = c.discount_id
ORDER BY c.created_at DESC LIMIT $1 OFFSET $2
`

type ListCouponsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListCouponsRow struct {
	ID                    uuid.UUID          `json:"id"`
	Code                  string             `json:"code"`
	DiscountID            uuid.UUID          `json:"discount_id"`
	UsageLimit            *int32             `json:"usage_limit"`
	UsageLimitPerCustomer *int32             `json:"usage_limit_per_customer"`
	UsageCount            int32              `json:"usage_count"`
	StartsAt              pgtype.Timestamptz `json:"starts_at"`
	EndsAt                pgtype.Timestamptz `json:"ends_at"`
	IsActive              bool               `json:"is_active"`
	CreatedAt             time.Time          `json:"created_at"`
	UpdatedAt             time.Time          `json:"updated_at"`
	DiscountName          string             `json:"discount_name"`
}

func (q *Queries) ListCoupons(ctx context.Context, arg ListCouponsParams) ([]ListCouponsRow, error) {
	rows, err := q.db.Query(ctx, listCoupons, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCouponsRow{}
	for rows.Next() {
		var i ListCouponsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.DiscountID,
			&i.UsageLimit,
			&i.UsageLimitPerCustomer,
			&i.UsageCount,
			&i.StartsAt,
			&i.EndsAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DiscountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDiscounts = `-- name: ListDiscounts :many
SELECT id, name, type, value, scope, minimum_amount, maximum_discount, starts_at, ends_at, is_active, priority, stackable, conditions, created_at, updated_at FROM discounts ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListDiscountsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDiscounts(ctx context.Context, arg ListDiscountsParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, listDiscounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Scope,
			&i.MinimumAmount,
			&i.MaximumDiscount,
			&i.StartsAt,
			&i.EndsAt,
			&i.IsActive,
			&i.Priority,
			&i.Stackable,
			&i.Conditions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDiscount = `-- name: UpdateDiscount :one
UPDATE discounts SET
  name = $2, type = $3, value = $4, scope = $5,
  minimum_amount = $6, maximum_discount = $7,
  starts_at = $8, ends_at = $9, is_active = $10,
  priority = $11, stackable = $12, conditions = $13, updated_at = $14
WHERE id = $1
RETURNING id, name, type, value, scope, minimum_amount, maximum_discount, starts_at, ends_at, is_active, priority, stackable, conditions, created_at, updated_at
`

type UpdateDiscountParams struct {
	ID              uuid.UUID          `json:"id"`
	Name            string             `json:"name"`
	Type            string             `json:"type"`
	Value           pgtype.Numeric     `json:"value"`
	Scope           string             `json:"scope"`
	MinimumAmount   pgtype.Numeric     `json:"minimum_amount"`
	MaximumDiscount pgtype.Numeric     `json:"maximum_discount"`
	StartsAt        pgtype.Timestamptz `json:"starts_at"`
	EndsAt          pgtype.Timestamptz `json:"ends_at"`
	IsActive        bool               `json:"is_active"`
	Priority        int32              `json:"priority"`
	Stackable       bool               `json:"stackable"`
	Conditions      json.RawMessage    `json:"conditions"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

func (q *Queries) UpdateDiscount(ctx context.Context, arg UpdateDiscountParams) (Discount, error) {
	row := q.db.QueryRow(ctx, updateDiscount,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Value,
		arg.Scope,
		arg.MinimumAmount,
		arg.MaximumDiscount,
		arg.StartsAt,
		arg.EndsAt,
		arg.IsActive,
		arg.Priority,
		arg.Stackable,
		arg.Conditions,
		arg.UpdatedAt,
	)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Value,
		&i.Scope,
		&i.MinimumAmount,
		&i.MaximumDiscount,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsActive,
		&i.Priority,
		&i.Stackable,
		&i.Conditions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
