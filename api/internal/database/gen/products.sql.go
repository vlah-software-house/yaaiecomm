// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addProductCategory = `-- name: AddProductCategory :exec
INSERT INTO product_categories (product_id, category_id, position)
VALUES ($1, $2, $3)
ON CONFLICT (product_id, category_id) DO UPDATE SET position = EXCLUDED.position
`

type AddProductCategoryParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	CategoryID uuid.UUID `json:"category_id"`
	Position   int32     `json:"position"`
}

func (q *Queries) AddProductCategory(ctx context.Context, arg AddProductCategoryParams) error {
	_, err := q.db.Exec(ctx, addProductCategory, arg.ProductID, arg.CategoryID, arg.Position)
	return err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products
WHERE ($1::text = '' OR status = $1::text)
`

func (q *Queries) CountProducts(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
  id, name, slug, description, short_description, status, sku_prefix,
  base_price, compare_at_price, vat_category_id,
  base_weight_grams, base_dimensions_mm,
  shipping_extra_fee_per_unit, has_variants,
  seo_title, seo_description, metadata,
  created_at, updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7,
  $8, $9, $10,
  $11, $12,
  $13, $14,
  $15, $16, $17,
  $18, $18
)
RETURNING id, name, slug, description, short_description, status, sku_prefix, base_price, compare_at_price, vat_category_id, base_weight_grams, base_dimensions_mm, shipping_extra_fee_per_unit, has_variants, seo_title, seo_description, metadata, created_at, updated_at
`

type CreateProductParams struct {
	ID                      uuid.UUID       `json:"id"`
	Name                    string          `json:"name"`
	Slug                    string          `json:"slug"`
	Description             *string         `json:"description"`
	ShortDescription        *string         `json:"short_description"`
	Status                  string          `json:"status"`
	SkuPrefix               *string         `json:"sku_prefix"`
	BasePrice               pgtype.Numeric  `json:"base_price"`
	CompareAtPrice          pgtype.Numeric  `json:"compare_at_price"`
	VatCategoryID           pgtype.UUID     `json:"vat_category_id"`
	BaseWeightGrams         int32           `json:"base_weight_grams"`
	BaseDimensionsMm        []byte          `json:"base_dimensions_mm"`
	ShippingExtraFeePerUnit pgtype.Numeric  `json:"shipping_extra_fee_per_unit"`
	HasVariants             bool            `json:"has_variants"`
	SeoTitle                *string         `json:"seo_title"`
	SeoDescription          *string         `json:"seo_description"`
	Metadata                json.RawMessage `json:"metadata"`
	CreatedAt               time.Time       `json:"created_at"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ShortDescription,
		arg.Status,
		arg.SkuPrefix,
		arg.BasePrice,
		arg.CompareAtPrice,
		arg.VatCategoryID,
		arg.BaseWeightGrams,
		arg.BaseDimensionsMm,
		arg.ShippingExtraFeePerUnit,
		arg.HasVariants,
		arg.SeoTitle,
		arg.SeoDescription,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.Status,
		&i.SkuPrefix,
		&i.BasePrice,
		&i.CompareAtPrice,
		&i.VatCategoryID,
		&i.BaseWeightGrams,
		&i.BaseDimensionsMm,
		&i.ShippingExtraFeePerUnit,
		&i.HasVariants,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const getProduct = `-- name: GetProduct :one
SELECT id, name, slug, description, short_description, status, sku_prefix, base_price, compare_at_price, vat_category_id, base_weight_grams, base_dimensions_mm, shipping_extra_fee_per_unit, has_variants, seo_title, seo_description, metadata, created_at, updated_at FROM products WHERE id = $1
`

func (q *Queries) GetProduct(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.Status,
		&i.SkuPrefix,
		&i.BasePrice,
		&i.CompareAtPrice,
		&i.VatCategoryID,
		&i.BaseWeightGrams,
		&i.BaseDimensionsMm,
		&i.ShippingExtraFeePerUnit,
		&i.HasVariants,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT id, name, slug, description, short_description, status, sku_prefix, base_price, compare_at_price, vat_category_id, base_weight_grams, base_dimensions_mm, shipping_extra_fee_per_unit, has_variants, seo_title, seo_description, metadata, created_at, updated_at FROM products WHERE slug = $1
`

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (Product, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, slug)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.Status,
		&i.SkuPrefix,
		&i.BasePrice,
		&i.CompareAtPrice,
		&i.VatCategoryID,
		&i.BaseWeightGrams,
		&i.BaseDimensionsMm,
		&i.ShippingExtraFeePerUnit,
		&i.HasVariants,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProductCategories = `-- name: ListProductCategories :many
SELECT c.id, c.name, c.slug, c.description, c.parent_id, c.position, c.image_url, c.seo_title, c.seo_description, c.is_active, c.created_at, c.updated_at FROM categories c
JOIN product_categories pc ON pc.category_id = c.id
WHERE pc.product_id = $1
ORDER BY pc.position
`

func (q *Queries) ListProductCategories(ctx context.Context, productID uuid.UUID) ([]Category, error) {
	rows, err := q.db.Query(ctx, listProductCategories, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.Position,
			&i.ImageUrl,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, name, slug, description, short_description, status, sku_prefix, base_price, compare_at_price, vat_category_id, base_weight_grams, base_dimensions_mm, shipping_extra_fee_per_unit, has_variants, seo_title, seo_description, metadata, created_at, updated_at FROM products
WHERE ($1::text = '' OR status = $1::text)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListProductsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.Status,
			&i.SkuPrefix,
			&i.BasePrice,
			&i.CompareAtPrice,
			&i.VatCategoryID,
			&i.BaseWeightGrams,
			&i.BaseDimensionsMm,
			&i.ShippingExtraFeePerUnit,
			&i.HasVariants,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, name, slug, description, short_description, status, sku_prefix, base_price, compare_at_price, vat_category_id, base_weight_grams, base_dimensions_mm, shipping_extra_fee_per_unit, has_variants, seo_title, seo_description, metadata, created_at, updated_at FROM products
WHERE (name ILIKE '%' || $1 || '%' OR sku_prefix ILIKE '%' || $1 || '%')
AND ($2::text = '' OR status = $2::text)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchProductsParams struct {
	Column1 *string `json:"column_1"`
	Column2 string  `json:"column_2"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, searchProducts,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.Status,
			&i.SkuPrefix,
			&i.BasePrice,
			&i.CompareAtPrice,
			&i.VatCategoryID,
			&i.BaseWeightGrams,
			&i.BaseDimensionsMm,
			&i.ShippingExtraFeePerUnit,
			&i.HasVariants,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setProductCategories = `-- name: SetProductCategories :exec
DELETE FROM product_categories WHERE product_id = $1
`

func (q *Queries) SetProductCategories(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, setProductCategories, productID)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products SET
  name = $2, slug = $3, description = $4, short_description = $5,
  status = $6, sku_prefix = $7,
  base_price = $8, compare_at_price = $9, vat_category_id = $10,
  base_weight_grams = $11, base_dimensions_mm = $12,
  shipping_extra_fee_per_unit = $13, has_variants = $14,
  seo_title = $15, seo_description = $16, metadata = $17,
  updated_at = $18
WHERE id = $1
RETURNING id, name, slug, description, short_description, status, sku_prefix, base_price, compare_at_price, vat_category_id, base_weight_grams, base_dimensions_mm, shipping_extra_fee_per_unit, has_variants, seo_title, seo_description, metadata, created_at, updated_at
`

type UpdateProductParams struct {
	ID                      uuid.UUID       `json:"id"`
	Name                    string          `json:"name"`
	Slug                    string          `json:"slug"`
	Description             *string         `json:"description"`
	ShortDescription        *string         `json:"short_description"`
	Status                  string          `json:"status"`
	SkuPrefix               *string         `json:"sku_prefix"`
	BasePrice               pgtype.Numeric  `json:"base_price"`
	CompareAtPrice          pgtype.Numeric  `json:"compare_at_price"`
	VatCategoryID           pgtype.UUID     `json:"vat_category_id"`
	BaseWeightGrams         int32           `json:"base_weight_grams"`
	BaseDimensionsMm        []byte          `json:"base_dimensions_mm"`
	ShippingExtraFeePerUnit pgtype.Numeric  `json:"shipping_extra_fee_per_unit"`
	HasVariants             bool            `json:"has_variants"`
	SeoTitle                *string         `json:"seo_title"`
	SeoDescription          *string         `json:"seo_description"`
	Metadata                json.RawMessage `json:"metadata"`
	UpdatedAt               time.Time       `json:"updated_at"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ShortDescription,
		arg.Status,
		arg.SkuPrefix,
		arg.BasePrice,
		arg.CompareAtPrice,
		arg.VatCategoryID,
		arg.BaseWeightGrams,
		arg.BaseDimensionsMm,
		arg.ShippingExtraFeePerUnit,
		arg.HasVariants,
		arg.SeoTitle,
		arg.SeoDescription,
		arg.Metadata,
		arg.UpdatedAt,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.Status,
		&i.SkuPrefix,
		&i.BasePrice,
		&i.CompareAtPrice,
		&i.VatCategoryID,
		&i.BaseWeightGrams,
		&i.BaseDimensionsMm,
		&i.ShippingExtraFeePerUnit,
		&i.HasVariants,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
