// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product_variants.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countLowStockVariants = `-- name: CountLowStockVariants :one
SELECT COUNT(*) FROM product_variants
WHERE stock_quantity <= low_stock_threshold AND is_active = true
`

func (q *Queries) CountLowStockVariants(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLowStockVariants)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProductVariant = `-- name: CreateProductVariant :one
INSERT INTO product_variants (
  id, product_id, sku, price, compare_at_price,
  weight_grams, dimensions_mm, stock_quantity, low_stock_threshold,
  barcode, is_active, position
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, product_id, sku, price, compare_at_price, weight_grams, dimensions_mm, stock_quantity, low_stock_threshold, barcode, is_active, position, created_at, updated_at
`

type CreateProductVariantParams struct {
	ID                uuid.UUID      `json:"id"`
	ProductID         uuid.UUID      `json:"product_id"`
	Sku               string         `json:"sku"`
	Price             pgtype.Numeric `json:"price"`
	CompareAtPrice    pgtype.Numeric `json:"compare_at_price"`
	WeightGrams       *int32         `json:"weight_grams"`
	DimensionsMm      []byte         `json:"dimensions_mm"`
	StockQuantity     int32          `json:"stock_quantity"`
	LowStockThreshold int32          `json:"low_stock_threshold"`
	Barcode           *string        `json:"barcode"`
	IsActive          bool           `json:"is_active"`
	Position          int32          `json:"position"`
}

func (q *Queries) CreateProductVariant(ctx context.Context, arg CreateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, createProductVariant,
		arg.ID,
		arg.ProductID,
		arg.Sku,
		arg.Price,
		arg.CompareAtPrice,
		arg.WeightGrams,
		arg.DimensionsMm,
		arg.StockQuantity,
		arg.LowStockThreshold,
		arg.Barcode,
		arg.IsActive,
		arg.Position,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.CompareAtPrice,
		&i.WeightGrams,
		&i.DimensionsMm,
		&i.StockQuantity,
		&i.LowStockThreshold,
		&i.Barcode,
		&i.IsActive,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProductVariant = `-- name: DeleteProductVariant :exec
DELETE FROM product_variants WHERE id = $1
`

func (q *Queries) DeleteProductVariant(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductVariant, id)
	return err
}

const deleteVariantOptions = `-- name: DeleteVariantOptions :exec
DELETE FROM product_variant_options WHERE variant_id = $1
`

func (q *Queries) DeleteVariantOptions(ctx context.Context, variantID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVariantOptions, variantID)
	return err
}

const getProductVariant = `-- name: GetProductVariant :one
SELECT id, product_id, sku, price, compare_at_price, weight_grams, dimensions_mm, stock_quantity, low_stock_threshold, barcode, is_active, position, created_at, updated_at FROM product_variants WHERE id = $1
`

func (q *Queries) GetProductVariant(ctx context.Context, id uuid.UUID) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, getProductVariant, id)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.CompareAtPrice,
		&i.WeightGrams,
		&i.DimensionsMm,
		&i.StockQuantity,
		&i.LowStockThreshold,
		&i.Barcode,
		&i.IsActive,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductVariantBySKU = `-- name: GetProductVariantBySKU :one
SELECT id, product_id, sku, price, compare_at_price, weight_grams, dimensions_mm, stock_quantity, low_stock_threshold, barcode, is_active, position, created_at, updated_at FROM product_variants WHERE sku = $1
`

func (q *Queries) GetProductVariantBySKU(ctx context.Context, sku string) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, getProductVariantBySKU, sku)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.CompareAtPrice,
		&i.WeightGrams,
		&i.DimensionsMm,
		&i.StockQuantity,
		&i.LowStockThreshold,
		&i.Barcode,
		&i.IsActive,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLowStockVariants = `-- name: ListLowStockVariants :many
SELECT pv.id, pv.product_id, pv.sku, pv.price, pv.compare_at_price, pv.weight_grams, pv.dimensions_mm, pv.stock_quantity, pv.low_stock_threshold, pv.barcode, pv.is_active, pv.position, pv.created_at, pv.updated_at, p.name as product_name FROM product_variants pv
JOIN products p ON p.id = pv.product_id
WHERE pv.stock_quantity <= pv.low_stock_threshold AND pv.is_active = true
ORDER BY pv.stock_quantity ASC
LIMIT $1
`

type ListLowStockVariantsRow struct {
	ID                uuid.UUID      `json:"id"`
	ProductID         uuid.UUID      `json:"product_id"`
	Sku               string         `json:"sku"`
	Price             pgtype.Numeric `json:"price"`
	CompareAtPrice    pgtype.Numeric `json:"compare_at_price"`
	WeightGrams       *int32         `json:"weight_grams"`
	DimensionsMm      []byte         `json:"dimensions_mm"`
	StockQuantity     int32          `json:"stock_quantity"`
	LowStockThreshold int32          `json:"low_stock_threshold"`
	Barcode           *string        `json:"barcode"`
	IsActive          bool           `json:"is_active"`
	Position          int32          `json:"position"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	ProductName       string         `json:"product_name"`
}

func (q *Queries) ListLowStockVariants(ctx context.Context, limit int32) ([]ListLowStockVariantsRow, error) {
	rows, err := q.db.Query(ctx, listLowStockVariants, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLowStockVariantsRow{}
	for rows.Next() {
		var i ListLowStockVariantsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.CompareAtPrice,
			&i.WeightGrams,
			&i.DimensionsMm,
			&i.StockQuantity,
			&i.LowStockThreshold,
			&i.Barcode,
			&i.IsActive,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductVariants = `-- name: ListProductVariants :many
SELECT id, product_id, sku, price, compare_at_price, weight_grams, dimensions_mm, stock_quantity, low_stock_threshold, barcode, is_active, position, created_at, updated_at FROM product_variants WHERE product_id = $1 ORDER BY position
`

func (q *Queries) ListProductVariants(ctx context.Context, productID uuid.UUID) ([]ProductVariant, error) {
	rows, err := q.db.Query(ctx, listProductVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductVariant{}
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.CompareAtPrice,
			&i.WeightGrams,
			&i.DimensionsMm,
			&i.StockQuantity,
			&i.LowStockThreshold,
			&i.Barcode,
			&i.IsActive,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVariantOptions = `-- name: ListVariantOptions :many
SELECT pvo.variant_id, pvo.attribute_id, pvo.option_id, pa.name as attribute_name, pao.value as option_value, pao.display_value as option_display_value
FROM product_variant_options pvo
JOIN product_attributes pa ON pa.id = pvo.attribute_id
JOIN product_attribute_options pao ON pao.id = pvo.option_id
WHERE pvo.variant_id = $1
ORDER BY pa.position
`

type ListVariantOptionsRow struct {
	VariantID          uuid.UUID `json:"variant_id"`
	AttributeID        uuid.UUID `json:"attribute_id"`
	OptionID           uuid.UUID `json:"option_id"`
	AttributeName      string    `json:"attribute_name"`
	OptionValue        string    `json:"option_value"`
	OptionDisplayValue string    `json:"option_display_value"`
}

func (q *Queries) ListVariantOptions(ctx context.Context, variantID uuid.UUID) ([]ListVariantOptionsRow, error) {
	rows, err := q.db.Query(ctx, listVariantOptions, variantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVariantOptionsRow{}
	for rows.Next() {
		var i ListVariantOptionsRow
		if err := rows.Scan(
			&i.VariantID,
			&i.AttributeID,
			&i.OptionID,
			&i.AttributeName,
			&i.OptionValue,
			&i.OptionDisplayValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setVariantOption = `-- name: SetVariantOption :exec
INSERT INTO product_variant_options (variant_id, attribute_id, option_id)
VALUES ($1, $2, $3)
ON CONFLICT (variant_id, attribute_id) DO UPDATE SET option_id = EXCLUDED.option_id
`

type SetVariantOptionParams struct {
	VariantID   uuid.UUID `json:"variant_id"`
	AttributeID uuid.UUID `json:"attribute_id"`
	OptionID    uuid.UUID `json:"option_id"`
}

func (q *Queries) SetVariantOption(ctx context.Context, arg SetVariantOptionParams) error {
	_, err := q.db.Exec(ctx, setVariantOption, arg.VariantID, arg.AttributeID, arg.OptionID)
	return err
}

const updateProductVariant = `-- name: UpdateProductVariant :one
UPDATE product_variants SET
  sku = $2, price = $3, compare_at_price = $4,
  weight_grams = $5, dimensions_mm = $6, stock_quantity = $7,
  low_stock_threshold = $8, barcode = $9, is_active = $10, position = $11
WHERE id = $1
RETURNING id, product_id, sku, price, compare_at_price, weight_grams, dimensions_mm, stock_quantity, low_stock_threshold, barcode, is_active, position, created_at, updated_at
`

type UpdateProductVariantParams struct {
	ID                uuid.UUID      `json:"id"`
	Sku               string         `json:"sku"`
	Price             pgtype.Numeric `json:"price"`
	CompareAtPrice    pgtype.Numeric `json:"compare_at_price"`
	WeightGrams       *int32         `json:"weight_grams"`
	DimensionsMm      []byte         `json:"dimensions_mm"`
	StockQuantity     int32          `json:"stock_quantity"`
	LowStockThreshold int32          `json:"low_stock_threshold"`
	Barcode           *string        `json:"barcode"`
	IsActive          bool           `json:"is_active"`
	Position          int32          `json:"position"`
}

func (q *Queries) UpdateProductVariant(ctx context.Context, arg UpdateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, updateProductVariant,
		arg.ID,
		arg.Sku,
		arg.Price,
		arg.CompareAtPrice,
		arg.WeightGrams,
		arg.DimensionsMm,
		arg.StockQuantity,
		arg.LowStockThreshold,
		arg.Barcode,
		arg.IsActive,
		arg.Position,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.CompareAtPrice,
		&i.WeightGrams,
		&i.DimensionsMm,
		&i.StockQuantity,
		&i.LowStockThreshold,
		&i.Barcode,
		&i.IsActive,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVariantStock = `-- name: UpdateVariantStock :exec
UPDATE product_variants SET stock_quantity = $2 WHERE id = $1
`

type UpdateVariantStockParams struct {
	ID            uuid.UUID `json:"id"`
	StockQuantity int32     `json:"stock_quantity"`
}

func (q *Queries) UpdateVariantStock(ctx context.Context, arg UpdateVariantStockParams) error {
	_, err := q.db.Exec(ctx, updateVariantStock, arg.ID, arg.StockQuantity)
	return err
}
