// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stock_movements.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createStockMovement = `-- name: CreateStockMovement :one
INSERT INTO stock_movements (
  id, entity_type, entity_id, movement_type,
  quantity_change, quantity_before, quantity_after,
  reference_type, reference_id, unit_cost, notes,
  created_by, created_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, entity_type, entity_id, movement_type, quantity_change, quantity_before, quantity_after, reference_type, reference_id, unit_cost, notes, created_by, created_at
`

type CreateStockMovementParams struct {
	ID             uuid.UUID      `json:"id"`
	EntityType     string         `json:"entity_type"`
	EntityID       uuid.UUID      `json:"entity_id"`
	MovementType   string         `json:"movement_type"`
	QuantityChange pgtype.Numeric `json:"quantity_change"`
	QuantityBefore pgtype.Numeric `json:"quantity_before"`
	QuantityAfter  pgtype.Numeric `json:"quantity_after"`
	ReferenceType  *string        `json:"reference_type"`
	ReferenceID    pgtype.UUID    `json:"reference_id"`
	UnitCost       pgtype.Numeric `json:"unit_cost"`
	Notes          *string        `json:"notes"`
	CreatedBy      pgtype.UUID    `json:"created_by"`
	CreatedAt      time.Time      `json:"created_at"`
}

func (q *Queries) CreateStockMovement(ctx context.Context, arg CreateStockMovementParams) (StockMovement, error) {
	row := q.db.QueryRow(ctx, createStockMovement,
		arg.ID,
		arg.EntityType,
		arg.EntityID,
		arg.MovementType,
		arg.QuantityChange,
		arg.QuantityBefore,
		arg.QuantityAfter,
		arg.ReferenceType,
		arg.ReferenceID,
		arg.UnitCost,
		arg.Notes,
		arg.CreatedBy,
		arg.CreatedAt,
	)
	var i StockMovement
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.MovementType,
		&i.QuantityChange,
		&i.QuantityBefore,
		&i.QuantityAfter,
		&i.ReferenceType,
		&i.ReferenceID,
		&i.UnitCost,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const listStockMovements = `-- name: ListStockMovements :many
SELECT id, entity_type, entity_id, movement_type, quantity_change, quantity_before, quantity_after, reference_type, reference_id, unit_cost, notes, created_by, created_at FROM stock_movements
WHERE entity_type = $1 AND entity_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListStockMovementsParams struct {
	EntityType string    `json:"entity_type"`
	EntityID   uuid.UUID `json:"entity_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) ListStockMovements(ctx context.Context, arg ListStockMovementsParams) ([]StockMovement, error) {
	rows, err := q.db.Query(ctx, listStockMovements,
		arg.EntityType,
		arg.EntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockMovement{}
	for rows.Next() {
		var i StockMovement
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.MovementType,
			&i.QuantityChange,
			&i.QuantityBefore,
			&i.QuantityAfter,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.UnitCost,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
