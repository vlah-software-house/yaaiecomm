// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countWebhookDeliveries = `-- name: CountWebhookDeliveries :one
SELECT COUNT(*) FROM webhook_deliveries WHERE endpoint_id = $1
`

func (q *Queries) CountWebhookDeliveries(ctx context.Context, endpointID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countWebhookDeliveries, endpointID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWebhookDelivery = `-- name: CreateWebhookDelivery :one
INSERT INTO webhook_deliveries (endpoint_id, event_type, payload)
VALUES ($1, $2, $3)
RETURNING id, endpoint_id, event_type, payload, response_status, response_body, attempt, delivered_at, next_retry_at, created_at
`

type CreateWebhookDeliveryParams struct {
	EndpointID uuid.UUID       `json:"endpoint_id"`
	EventType  string          `json:"event_type"`
	Payload    json.RawMessage `json:"payload"`
}

func (q *Queries) CreateWebhookDelivery(ctx context.Context, arg CreateWebhookDeliveryParams) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, createWebhookDelivery, arg.EndpointID, arg.EventType, arg.Payload)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.EventType,
		&i.Payload,
		&i.ResponseStatus,
		&i.ResponseBody,
		&i.Attempt,
		&i.DeliveredAt,
		&i.NextRetryAt,
		&i.CreatedAt,
	)
	return i, err
}

const createWebhookEndpoint = `-- name: CreateWebhookEndpoint :one
INSERT INTO webhook_endpoints (url, secret, events, description, is_active)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, url, secret, events, is_active, description, created_at, updated_at
`

type CreateWebhookEndpointParams struct {
	Url         string   `json:"url"`
	Secret      string   `json:"secret"`
	Events      []string `json:"events"`
	Description *string  `json:"description"`
	IsActive    bool     `json:"is_active"`
}

func (q *Queries) CreateWebhookEndpoint(ctx context.Context, arg CreateWebhookEndpointParams) (WebhookEndpoint, error) {
	row := q.db.QueryRow(ctx, createWebhookEndpoint,
		arg.Url,
		arg.Secret,
		arg.Events,
		arg.Description,
		arg.IsActive,
	)
	var i WebhookEndpoint
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.IsActive,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteWebhookEndpoint = `-- name: DeleteWebhookEndpoint :exec
DELETE FROM webhook_endpoints WHERE id = $1
`

func (q *Queries) DeleteWebhookEndpoint(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWebhookEndpoint, id)
	return err
}

const getWebhookEndpoint = `-- name: GetWebhookEndpoint :one
SELECT id, url, secret, events, is_active, description, created_at, updated_at FROM webhook_endpoints WHERE id = $1
`

func (q *Queries) GetWebhookEndpoint(ctx context.Context, id uuid.UUID) (WebhookEndpoint, error) {
	row := q.db.QueryRow(ctx, getWebhookEndpoint, id)
	var i WebhookEndpoint
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.IsActive,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveWebhookEndpoints = `-- name: ListActiveWebhookEndpoints :many
SELECT id, url, secret, events, is_active, description, created_at, updated_at FROM webhook_endpoints WHERE is_active = true ORDER BY created_at DESC
`

func (q *Queries) ListActiveWebhookEndpoints(ctx context.Context) ([]WebhookEndpoint, error) {
	rows, err := q.db.Query(ctx, listActiveWebhookEndpoints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookEndpoint{}
	for rows.Next() {
		var i WebhookEndpoint
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.IsActive,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingWebhookDeliveries = `-- name: ListPendingWebhookDeliveries :many
SELECT wd.id, wd.endpoint_id, wd.event_type, wd.payload, wd.response_status, wd.response_body, wd.attempt, wd.delivered_at, wd.next_retry_at, wd.created_at, we.url, we.secret
FROM webhook_deliveries wd
JOIN webhook_endpoints we ON we.id = wd.endpoint_id
WHERE wd.delivered_at IS NULL
  AND (wd.next_retry_at IS NULL OR wd.next_retry_at <= NOW())
  AND wd.attempt < 5
ORDER BY wd.created_at ASC
LIMIT $1
`

type ListPendingWebhookDeliveriesRow struct {
	ID             uuid.UUID          `json:"id"`
	EndpointID     uuid.UUID          `json:"endpoint_id"`
	EventType      string             `json:"event_type"`
	Payload        json.RawMessage    `json:"payload"`
	ResponseStatus *int32             `json:"response_status"`
	ResponseBody   *string            `json:"response_body"`
	Attempt        int32              `json:"attempt"`
	DeliveredAt    pgtype.Timestamptz `json:"delivered_at"`
	NextRetryAt    pgtype.Timestamptz `json:"next_retry_at"`
	CreatedAt      time.Time          `json:"created_at"`
	Url            string             `json:"url"`
	Secret         string             `json:"secret"`
}

func (q *Queries) ListPendingWebhookDeliveries(ctx context.Context, limit int32) ([]ListPendingWebhookDeliveriesRow, error) {
	rows, err := q.db.Query(ctx, listPendingWebhookDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingWebhookDeliveriesRow{}
	for rows.Next() {
		var i ListPendingWebhookDeliveriesRow
		if err := rows.Scan(
			&i.ID,
			&i.EndpointID,
			&i.EventType,
			&i.Payload,
			&i.ResponseStatus,
			&i.ResponseBody,
			&i.Attempt,
			&i.DeliveredAt,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.Url,
			&i.Secret,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookDeliveries = `-- name: ListWebhookDeliveries :many
SELECT id, endpoint_id, event_type, payload, response_status, response_body, attempt, delivered_at, next_retry_at, created_at FROM webhook_deliveries
WHERE endpoint_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListWebhookDeliveriesParams struct {
	EndpointID uuid.UUID `json:"endpoint_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) ListWebhookDeliveries(ctx context.Context, arg ListWebhookDeliveriesParams) ([]WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, listWebhookDeliveries, arg.EndpointID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.EndpointID,
			&i.EventType,
			&i.Payload,
			&i.ResponseStatus,
			&i.ResponseBody,
			&i.Attempt,
			&i.DeliveredAt,
			&i.NextRetryAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookEndpoints = `-- name: ListWebhookEndpoints :many
SELECT id, url, secret, events, is_active, description, created_at, updated_at FROM webhook_endpoints ORDER BY created_at DESC
`

func (q *Queries) ListWebhookEndpoints(ctx context.Context) ([]WebhookEndpoint, error) {
	rows, err := q.db.Query(ctx, listWebhookEndpoints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookEndpoint{}
	for rows.Next() {
		var i WebhookEndpoint
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.IsActive,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWebhookDeliveryFailed = `-- name: UpdateWebhookDeliveryFailed :exec
UPDATE webhook_deliveries
SET response_status = $2, response_body = $3, attempt = attempt + 1, next_retry_at = $4
WHERE id = $1
`

type UpdateWebhookDeliveryFailedParams struct {
	ID             uuid.UUID          `json:"id"`
	ResponseStatus *int32             `json:"response_status"`
	ResponseBody   *string            `json:"response_body"`
	NextRetryAt    pgtype.Timestamptz `json:"next_retry_at"`
}

func (q *Queries) UpdateWebhookDeliveryFailed(ctx context.Context, arg UpdateWebhookDeliveryFailedParams) error {
	_, err := q.db.Exec(ctx, updateWebhookDeliveryFailed,
		arg.ID,
		arg.ResponseStatus,
		arg.ResponseBody,
		arg.NextRetryAt,
	)
	return err
}

const updateWebhookDeliverySuccess = `-- name: UpdateWebhookDeliverySuccess :exec
UPDATE webhook_deliveries
SET response_status = $2, response_body = $3, delivered_at = NOW(), attempt = attempt + 1
WHERE id = $1
`

type UpdateWebhookDeliverySuccessParams struct {
	ID             uuid.UUID `json:"id"`
	ResponseStatus *int32    `json:"response_status"`
	ResponseBody   *string   `json:"response_body"`
}

func (q *Queries) UpdateWebhookDeliverySuccess(ctx context.Context, arg UpdateWebhookDeliverySuccessParams) error {
	_, err := q.db.Exec(ctx, updateWebhookDeliverySuccess, arg.ID, arg.ResponseStatus, arg.ResponseBody)
	return err
}

const updateWebhookEndpoint = `-- name: UpdateWebhookEndpoint :one
UPDATE webhook_endpoints
SET url = $2, events = $3, description = $4, is_active = $5, updated_at = NOW()
WHERE id = $1
RETURNING id, url, secret, events, is_active, description, created_at, updated_at
`

type UpdateWebhookEndpointParams struct {
	ID          uuid.UUID `json:"id"`
	Url         string    `json:"url"`
	Events      []string  `json:"events"`
	Description *string   `json:"description"`
	IsActive    bool      `json:"is_active"`
}

func (q *Queries) UpdateWebhookEndpoint(ctx context.Context, arg UpdateWebhookEndpointParams) (WebhookEndpoint, error) {
	row := q.db.QueryRow(ctx, updateWebhookEndpoint,
		arg.ID,
		arg.Url,
		arg.Events,
		arg.Description,
		arg.IsActive,
	)
	var i WebhookEndpoint
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.IsActive,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
