// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vat.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteProductVATOverride = `-- name: DeleteProductVATOverride :exec
DELETE FROM product_vat_overrides WHERE id = $1
`

func (q *Queries) DeleteProductVATOverride(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductVATOverride, id)
	return err
}

const getEUCountry = `-- name: GetEUCountry :one
SELECT country_code, name, local_vat_name, local_vat_abbreviation, is_eu_member, currency FROM eu_countries WHERE country_code = $1
`

func (q *Queries) GetEUCountry(ctx context.Context, countryCode string) (EuCountry, error) {
	row := q.db.QueryRow(ctx, getEUCountry, countryCode)
	var i EuCountry
	err := row.Scan(
		&i.CountryCode,
		&i.Name,
		&i.LocalVatName,
		&i.LocalVatAbbreviation,
		&i.IsEuMember,
		&i.Currency,
	)
	return i, err
}

const getStoreSettings = `-- name: GetStoreSettings :one
SELECT id, store_name, store_email, store_phone, store_address, default_currency, vat_enabled, vat_number, vat_country_code, vat_prices_include_vat, vat_default_category, vat_b2b_reverse_charge_enabled, created_at, updated_at FROM store_settings LIMIT 1
`

func (q *Queries) GetStoreSettings(ctx context.Context) (StoreSetting, error) {
	row := q.db.QueryRow(ctx, getStoreSettings)
	var i StoreSetting
	err := row.Scan(
		&i.ID,
		&i.StoreName,
		&i.StoreEmail,
		&i.StorePhone,
		&i.StoreAddress,
		&i.DefaultCurrency,
		&i.VatEnabled,
		&i.VatNumber,
		&i.VatCountryCode,
		&i.VatPricesIncludeVat,
		&i.VatDefaultCategory,
		&i.VatB2bReverseChargeEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVATCategory = `-- name: GetVATCategory :one
SELECT id, name, display_name, description, maps_to_rate_type, is_default, position, created_at FROM vat_categories WHERE id = $1
`

func (q *Queries) GetVATCategory(ctx context.Context, id uuid.UUID) (VatCategory, error) {
	row := q.db.QueryRow(ctx, getVATCategory, id)
	var i VatCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.MapsToRateType,
		&i.IsDefault,
		&i.Position,
		&i.CreatedAt,
	)
	return i, err
}

const getVATCategoryByName = `-- name: GetVATCategoryByName :one
SELECT id, name, display_name, description, maps_to_rate_type, is_default, position, created_at FROM vat_categories WHERE name = $1
`

func (q *Queries) GetVATCategoryByName(ctx context.Context, name string) (VatCategory, error) {
	row := q.db.QueryRow(ctx, getVATCategoryByName, name)
	var i VatCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.MapsToRateType,
		&i.IsDefault,
		&i.Position,
		&i.CreatedAt,
	)
	return i, err
}

const getVATRate = `-- name: GetVATRate :one
SELECT id, country_code, rate_type, rate, description, valid_from, valid_to, source, synced_at FROM vat_rates WHERE country_code = $1 AND rate_type = $2 AND valid_to IS NULL
`

type GetVATRateParams struct {
	CountryCode string `json:"country_code"`
	RateType    string `json:"rate_type"`
}

func (q *Queries) GetVATRate(ctx context.Context, arg GetVATRateParams) (VatRate, error) {
	row := q.db.QueryRow(ctx, getVATRate, arg.CountryCode, arg.RateType)
	var i VatRate
	err := row.Scan(
		&i.ID,
		&i.CountryCode,
		&i.RateType,
		&i.Rate,
		&i.Description,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Source,
		&i.SyncedAt,
	)
	return i, err
}

const listActiveVATRates = `-- name: ListActiveVATRates :many
SELECT id, country_code, rate_type, rate, description, valid_from, valid_to, source, synced_at FROM vat_rates WHERE valid_to IS NULL ORDER BY country_code, rate_type
`

func (q *Queries) ListActiveVATRates(ctx context.Context) ([]VatRate, error) {
	rows, err := q.db.Query(ctx, listActiveVATRates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VatRate{}
	for rows.Next() {
		var i VatRate
		if err := rows.Scan(
			&i.ID,
			&i.CountryCode,
			&i.RateType,
			&i.Rate,
			&i.Description,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Source,
			&i.SyncedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEUCountries = `-- name: ListEUCountries :many
SELECT country_code, name, local_vat_name, local_vat_abbreviation, is_eu_member, currency FROM eu_countries WHERE is_eu_member = true ORDER BY name
`

func (q *Queries) ListEUCountries(ctx context.Context) ([]EuCountry, error) {
	rows, err := q.db.Query(ctx, listEUCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EuCountry{}
	for rows.Next() {
		var i EuCountry
		if err := rows.Scan(
			&i.CountryCode,
			&i.Name,
			&i.LocalVatName,
			&i.LocalVatAbbreviation,
			&i.IsEuMember,
			&i.Currency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledShippingCountries = `-- name: ListEnabledShippingCountries :many
SELECT ec.country_code, ec.name, ec.local_vat_name, ec.local_vat_abbreviation, ec.is_eu_member, ec.currency FROM eu_countries ec
JOIN store_shipping_countries ssc ON ssc.country_code = ec.country_code
WHERE ssc.is_enabled = true
ORDER BY ec.name
`

func (q *Queries) ListEnabledShippingCountries(ctx context.Context) ([]EuCountry, error) {
	rows, err := q.db.Query(ctx, listEnabledShippingCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EuCountry{}
	for rows.Next() {
		var i EuCountry
		if err := rows.Scan(
			&i.CountryCode,
			&i.Name,
			&i.LocalVatName,
			&i.LocalVatAbbreviation,
			&i.IsEuMember,
			&i.Currency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductVATOverrides = `-- name: ListProductVATOverrides :many
SELECT pvo.id, pvo.product_id, pvo.country_code, pvo.vat_category_id, pvo.notes, pvo.created_at, pvo.updated_at, vc.name as category_name, vc.display_name as category_display_name,
       ec.name as country_name
FROM product_vat_overrides pvo
JOIN vat_categories vc ON vc.id = pvo.vat_category_id
JOIN eu_countries ec ON ec.country_code = pvo.country_code
WHERE pvo.product_id = $1
ORDER BY ec.name
`

type ListProductVATOverridesRow struct {
	ID                  uuid.UUID `json:"id"`
	ProductID           uuid.UUID `json:"product_id"`
	CountryCode         string    `json:"country_code"`
	VatCategoryID       uuid.UUID `json:"vat_category_id"`
	Notes               *string   `json:"notes"`
	CreatedAt           time.Time `json:"created_at"`
	UpdatedAt           time.Time `json:"updated_at"`
	CategoryName        string    `json:"category_name"`
	CategoryDisplayName string    `json:"category_display_name"`
	CountryName         string    `json:"country_name"`
}

func (q *Queries) ListProductVATOverrides(ctx context.Context, productID uuid.UUID) ([]ListProductVATOverridesRow, error) {
	rows, err := q.db.Query(ctx, listProductVATOverrides, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProductVATOverridesRow{}
	for rows.Next() {
		var i ListProductVATOverridesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.CountryCode,
			&i.VatCategoryID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.CategoryDisplayName,
			&i.CountryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoreShippingCountries = `-- name: ListStoreShippingCountries :many
SELECT ssc.country_code, ssc.is_enabled, ssc.shipping_zone_id, ssc.position, ssc.created_at, ec.name as country_name FROM store_shipping_countries ssc
JOIN eu_countries ec ON ec.country_code = ssc.country_code
ORDER BY ssc.position, ec.name
`

type ListStoreShippingCountriesRow struct {
	CountryCode    string      `json:"country_code"`
	IsEnabled      bool        `json:"is_enabled"`
	ShippingZoneID pgtype.UUID `json:"shipping_zone_id"`
	Position       int32       `json:"position"`
	CreatedAt      time.Time   `json:"created_at"`
	CountryName    string      `json:"country_name"`
}

func (q *Queries) ListStoreShippingCountries(ctx context.Context) ([]ListStoreShippingCountriesRow, error) {
	rows, err := q.db.Query(ctx, listStoreShippingCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStoreShippingCountriesRow{}
	for rows.Next() {
		var i ListStoreShippingCountriesRow
		if err := rows.Scan(
			&i.CountryCode,
			&i.IsEnabled,
			&i.ShippingZoneID,
			&i.Position,
			&i.CreatedAt,
			&i.CountryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVATCategories = `-- name: ListVATCategories :many
SELECT id, name, display_name, description, maps_to_rate_type, is_default, position, created_at FROM vat_categories ORDER BY position
`

func (q *Queries) ListVATCategories(ctx context.Context) ([]VatCategory, error) {
	rows, err := q.db.Query(ctx, listVATCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VatCategory{}
	for rows.Next() {
		var i VatCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.MapsToRateType,
			&i.IsDefault,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVATRatesByCountry = `-- name: ListVATRatesByCountry :many
SELECT id, country_code, rate_type, rate, description, valid_from, valid_to, source, synced_at FROM vat_rates WHERE country_code = $1 AND valid_to IS NULL ORDER BY rate_type
`

func (q *Queries) ListVATRatesByCountry(ctx context.Context, countryCode string) ([]VatRate, error) {
	rows, err := q.db.Query(ctx, listVATRatesByCountry, countryCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VatRate{}
	for rows.Next() {
		var i VatRate
		if err := rows.Scan(
			&i.ID,
			&i.CountryCode,
			&i.RateType,
			&i.Rate,
			&i.Description,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Source,
			&i.SyncedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setShippingCountryEnabled = `-- name: SetShippingCountryEnabled :exec
UPDATE store_shipping_countries SET is_enabled = $2 WHERE country_code = $1
`

type SetShippingCountryEnabledParams struct {
	CountryCode string `json:"country_code"`
	IsEnabled   bool   `json:"is_enabled"`
}

func (q *Queries) SetShippingCountryEnabled(ctx context.Context, arg SetShippingCountryEnabledParams) error {
	_, err := q.db.Exec(ctx, setShippingCountryEnabled, arg.CountryCode, arg.IsEnabled)
	return err
}

const updateStoreVATSettings = `-- name: UpdateStoreVATSettings :exec
UPDATE store_settings SET
  vat_enabled = $1, vat_number = $2, vat_country_code = $3,
  vat_prices_include_vat = $4, vat_default_category = $5,
  vat_b2b_reverse_charge_enabled = $6, updated_at = $7
WHERE id = (SELECT id FROM store_settings LIMIT 1)
`

type UpdateStoreVATSettingsParams struct {
	VatEnabled                 bool      `json:"vat_enabled"`
	VatNumber                  *string   `json:"vat_number"`
	VatCountryCode             *string   `json:"vat_country_code"`
	VatPricesIncludeVat        bool      `json:"vat_prices_include_vat"`
	VatDefaultCategory         string    `json:"vat_default_category"`
	VatB2bReverseChargeEnabled bool      `json:"vat_b2b_reverse_charge_enabled"`
	UpdatedAt                  time.Time `json:"updated_at"`
}

func (q *Queries) UpdateStoreVATSettings(ctx context.Context, arg UpdateStoreVATSettingsParams) error {
	_, err := q.db.Exec(ctx, updateStoreVATSettings,
		arg.VatEnabled,
		arg.VatNumber,
		arg.VatCountryCode,
		arg.VatPricesIncludeVat,
		arg.VatDefaultCategory,
		arg.VatB2bReverseChargeEnabled,
		arg.UpdatedAt,
	)
	return err
}

const upsertProductVATOverride = `-- name: UpsertProductVATOverride :one
INSERT INTO product_vat_overrides (id, product_id, country_code, vat_category_id, notes, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $6)
ON CONFLICT (product_id, country_code)
DO UPDATE SET vat_category_id = EXCLUDED.vat_category_id, notes = EXCLUDED.notes, updated_at = EXCLUDED.updated_at
RETURNING id, product_id, country_code, vat_category_id, notes, created_at, updated_at
`

type UpsertProductVATOverrideParams struct {
	ID            uuid.UUID `json:"id"`
	ProductID     uuid.UUID `json:"product_id"`
	CountryCode   string    `json:"country_code"`
	VatCategoryID uuid.UUID `json:"vat_category_id"`
	Notes         *string   `json:"notes"`
	CreatedAt     time.Time `json:"created_at"`
}

func (q *Queries) UpsertProductVATOverride(ctx context.Context, arg UpsertProductVATOverrideParams) (ProductVatOverride, error) {
	row := q.db.QueryRow(ctx, upsertProductVATOverride,
		arg.ID,
		arg.ProductID,
		arg.CountryCode,
		arg.VatCategoryID,
		arg.Notes,
		arg.CreatedAt,
	)
	var i ProductVatOverride
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.CountryCode,
		&i.VatCategoryID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
