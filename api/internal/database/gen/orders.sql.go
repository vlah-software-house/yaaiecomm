// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT COUNT(*) FROM orders
WHERE ($1::text IS NULL OR status = $1::text)
`

func (q *Queries) CountOrders(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersToday = `-- name: CountOrdersToday :one
SELECT COUNT(*) FROM orders WHERE created_at >= CURRENT_DATE
`

func (q *Queries) CountOrdersToday(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersToday)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingOrders = `-- name: CountPendingOrders :one
SELECT COUNT(*) FROM orders WHERE status = 'pending'
`

func (q *Queries) CountPendingOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingOrders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
  id, order_number, customer_id, status, email,
  billing_address, shipping_address,
  subtotal, shipping_fee, shipping_extra_fees, discount_amount,
  vat_total, total,
  vat_number, vat_company_name, vat_reverse_charge, vat_country_code,
  stripe_payment_intent_id, stripe_checkout_session_id, payment_status,
  discount_id, coupon_id, discount_breakdown,
  shipping_method, notes, customer_notes, metadata,
  created_at, updated_at
) VALUES (
  $1, nextval('order_number_seq'), $2, $3, $4,
  $5, $6,
  $7, $8, $9, $10,
  $11, $12,
  $13, $14, $15, $16,
  $17, $18, $19,
  $20, $21, $22,
  $23, $24, $25, $26,
  $27, $27
)
RETURNING id, order_number, customer_id, status, email, billing_address, shipping_address, subtotal, shipping_fee, shipping_extra_fees, discount_amount, vat_total, total, vat_number, vat_company_name, vat_reverse_charge, vat_country_code, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, discount_id, coupon_id, discount_breakdown, shipping_method, tracking_number, shipped_at, delivered_at, notes, customer_notes, metadata, created_at, updated_at
`

type CreateOrderParams struct {
	ID                      uuid.UUID       `json:"id"`
	CustomerID              pgtype.UUID     `json:"customer_id"`
	Status                  string          `json:"status"`
	Email                   string          `json:"email"`
	BillingAddress          json.RawMessage `json:"billing_address"`
	ShippingAddress         json.RawMessage `json:"shipping_address"`
	Subtotal                pgtype.Numeric  `json:"subtotal"`
	ShippingFee             pgtype.Numeric  `json:"shipping_fee"`
	ShippingExtraFees       pgtype.Numeric  `json:"shipping_extra_fees"`
	DiscountAmount          pgtype.Numeric  `json:"discount_amount"`
	VatTotal                pgtype.Numeric  `json:"vat_total"`
	Total                   pgtype.Numeric  `json:"total"`
	VatNumber               *string         `json:"vat_number"`
	VatCompanyName          *string         `json:"vat_company_name"`
	VatReverseCharge        bool            `json:"vat_reverse_charge"`
	VatCountryCode          *string         `json:"vat_country_code"`
	StripePaymentIntentID   *string         `json:"stripe_payment_intent_id"`
	StripeCheckoutSessionID *string         `json:"stripe_checkout_session_id"`
	PaymentStatus           string          `json:"payment_status"`
	DiscountID              pgtype.UUID     `json:"discount_id"`
	CouponID                pgtype.UUID     `json:"coupon_id"`
	DiscountBreakdown       []byte          `json:"discount_breakdown"`
	ShippingMethod          *string         `json:"shipping_method"`
	Notes                   *string         `json:"notes"`
	CustomerNotes           *string         `json:"customer_notes"`
	Metadata                json.RawMessage `json:"metadata"`
	CreatedAt               time.Time       `json:"created_at"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ID,
		arg.CustomerID,
		arg.Status,
		arg.Email,
		arg.BillingAddress,
		arg.ShippingAddress,
		arg.Subtotal,
		arg.ShippingFee,
		arg.ShippingExtraFees,
		arg.DiscountAmount,
		arg.VatTotal,
		arg.Total,
		arg.VatNumber,
		arg.VatCompanyName,
		arg.VatReverseCharge,
		arg.VatCountryCode,
		arg.StripePaymentIntentID,
		arg.StripeCheckoutSessionID,
		arg.PaymentStatus,
		arg.DiscountID,
		arg.CouponID,
		arg.DiscountBreakdown,
		arg.ShippingMethod,
		arg.Notes,
		arg.CustomerNotes,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.Status,
		&i.Email,
		&i.BillingAddress,
		&i.ShippingAddress,
		&i.Subtotal,
		&i.ShippingFee,
		&i.ShippingExtraFees,
		&i.DiscountAmount,
		&i.VatTotal,
		&i.Total,
		&i.VatNumber,
		&i.VatCompanyName,
		&i.VatReverseCharge,
		&i.VatCountryCode,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.DiscountID,
		&i.CouponID,
		&i.DiscountBreakdown,
		&i.ShippingMethod,
		&i.TrackingNumber,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.Notes,
		&i.CustomerNotes,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderEvent = `-- name: CreateOrderEvent :exec
INSERT INTO order_events (id, order_id, event_type, from_status, to_status, data, created_by, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateOrderEventParams struct {
	ID         uuid.UUID   `json:"id"`
	OrderID    uuid.UUID   `json:"order_id"`
	EventType  string      `json:"event_type"`
	FromStatus *string     `json:"from_status"`
	ToStatus   *string     `json:"to_status"`
	Data       []byte      `json:"data"`
	CreatedBy  pgtype.UUID `json:"created_by"`
	CreatedAt  time.Time   `json:"created_at"`
}

func (q *Queries) CreateOrderEvent(ctx context.Context, arg CreateOrderEventParams) error {
	_, err := q.db.Exec(ctx, createOrderEvent,
		arg.ID,
		arg.OrderID,
		arg.EventType,
		arg.FromStatus,
		arg.ToStatus,
		arg.Data,
		arg.CreatedBy,
		arg.CreatedAt,
	)
	return err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (
  id, order_id, product_id, variant_id,
  product_name, variant_name, variant_options, sku,
  quantity, unit_price, total_price,
  vat_rate, vat_rate_type, vat_amount,
  price_includes_vat, net_unit_price, gross_unit_price,
  weight_grams, metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
RETURNING id, order_id, product_id, variant_id, product_name, variant_name, variant_options, sku, quantity, unit_price, total_price, vat_rate, vat_rate_type, vat_amount, price_includes_vat, net_unit_price, gross_unit_price, weight_grams, metadata, created_at
`

type CreateOrderItemParams struct {
	ID               uuid.UUID       `json:"id"`
	OrderID          uuid.UUID       `json:"order_id"`
	ProductID        pgtype.UUID     `json:"product_id"`
	VariantID        pgtype.UUID     `json:"variant_id"`
	ProductName      string          `json:"product_name"`
	VariantName      *string         `json:"variant_name"`
	VariantOptions   []byte          `json:"variant_options"`
	Sku              *string         `json:"sku"`
	Quantity         int32           `json:"quantity"`
	UnitPrice        pgtype.Numeric  `json:"unit_price"`
	TotalPrice       pgtype.Numeric  `json:"total_price"`
	VatRate          pgtype.Numeric  `json:"vat_rate"`
	VatRateType      *string         `json:"vat_rate_type"`
	VatAmount        pgtype.Numeric  `json:"vat_amount"`
	PriceIncludesVat bool            `json:"price_includes_vat"`
	NetUnitPrice     pgtype.Numeric  `json:"net_unit_price"`
	GrossUnitPrice   pgtype.Numeric  `json:"gross_unit_price"`
	WeightGrams      *int32          `json:"weight_grams"`
	Metadata         json.RawMessage `json:"metadata"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.ID,
		arg.OrderID,
		arg.ProductID,
		arg.VariantID,
		arg.ProductName,
		arg.VariantName,
		arg.VariantOptions,
		arg.Sku,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
		arg.VatRate,
		arg.VatRateType,
		arg.VatAmount,
		arg.PriceIncludesVat,
		arg.NetUnitPrice,
		arg.GrossUnitPrice,
		arg.WeightGrams,
		arg.Metadata,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.VariantID,
		&i.ProductName,
		&i.VariantName,
		&i.VariantOptions,
		&i.Sku,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.VatRate,
		&i.VatRateType,
		&i.VatAmount,
		&i.PriceIncludesVat,
		&i.NetUnitPrice,
		&i.GrossUnitPrice,
		&i.WeightGrams,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT id, order_number, customer_id, status, email, billing_address, shipping_address, subtotal, shipping_fee, shipping_extra_fees, discount_amount, vat_total, total, vat_number, vat_company_name, vat_reverse_charge, vat_country_code, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, discount_id, coupon_id, discount_breakdown, shipping_method, tracking_number, shipped_at, delivered_at, notes, customer_notes, metadata, created_at, updated_at FROM orders WHERE id = $1
`

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.Status,
		&i.Email,
		&i.BillingAddress,
		&i.ShippingAddress,
		&i.Subtotal,
		&i.ShippingFee,
		&i.ShippingExtraFees,
		&i.DiscountAmount,
		&i.VatTotal,
		&i.Total,
		&i.VatNumber,
		&i.VatCompanyName,
		&i.VatReverseCharge,
		&i.VatCountryCode,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.DiscountID,
		&i.CouponID,
		&i.DiscountBreakdown,
		&i.ShippingMethod,
		&i.TrackingNumber,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.Notes,
		&i.CustomerNotes,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderByNumber = `-- name: GetOrderByNumber :one
SELECT id, order_number, customer_id, status, email, billing_address, shipping_address, subtotal, shipping_fee, shipping_extra_fees, discount_amount, vat_total, total, vat_number, vat_company_name, vat_reverse_charge, vat_country_code, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, discount_id, coupon_id, discount_breakdown, shipping_method, tracking_number, shipped_at, delivered_at, notes, customer_notes, metadata, created_at, updated_at FROM orders WHERE order_number = $1
`

func (q *Queries) GetOrderByNumber(ctx context.Context, orderNumber int64) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByNumber, orderNumber)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.Status,
		&i.Email,
		&i.BillingAddress,
		&i.ShippingAddress,
		&i.Subtotal,
		&i.ShippingFee,
		&i.ShippingExtraFees,
		&i.DiscountAmount,
		&i.VatTotal,
		&i.Total,
		&i.VatNumber,
		&i.VatCompanyName,
		&i.VatReverseCharge,
		&i.VatCountryCode,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.DiscountID,
		&i.CouponID,
		&i.DiscountBreakdown,
		&i.ShippingMethod,
		&i.TrackingNumber,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.Notes,
		&i.CustomerNotes,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listOrderEvents = `-- name: ListOrderEvents :many
SELECT id, order_id, event_type, from_status, to_status, data, created_by, created_at FROM order_events WHERE order_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListOrderEvents(ctx context.Context, orderID uuid.UUID) ([]OrderEvent, error) {
	rows, err := q.db.Query(ctx, listOrderEvents, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderEvent{}
	for rows.Next() {
		var i OrderEvent
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.EventType,
			&i.FromStatus,
			&i.ToStatus,
			&i.Data,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItems = `-- name: ListOrderItems :many
SELECT id, order_id, product_id, variant_id, product_name, variant_name, variant_options, sku, quantity, unit_price, total_price, vat_rate, vat_rate_type, vat_amount, price_includes_vat, net_unit_price, gross_unit_price, weight_grams, metadata, created_at FROM order_items WHERE order_id = $1 ORDER BY id
`

func (q *Queries) ListOrderItems(ctx context.Context, orderID uuid.UUID) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, listOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.VariantID,
			&i.ProductName,
			&i.VariantName,
			&i.VariantOptions,
			&i.Sku,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.VatRate,
			&i.VatRateType,
			&i.VatAmount,
			&i.PriceIncludesVat,
			&i.NetUnitPrice,
			&i.GrossUnitPrice,
			&i.WeightGrams,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT id, order_number, customer_id, status, email, billing_address, shipping_address, subtotal, shipping_fee, shipping_extra_fees, discount_amount, vat_total, total, vat_number, vat_company_name, vat_reverse_charge, vat_country_code, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, discount_id, coupon_id, discount_breakdown, shipping_method, tracking_number, shipped_at, delivered_at, notes, customer_notes, metadata, created_at, updated_at FROM orders
WHERE ($1::text IS NULL OR status = $1::text)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrders, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.Status,
			&i.Email,
			&i.BillingAddress,
			&i.ShippingAddress,
			&i.Subtotal,
			&i.ShippingFee,
			&i.ShippingExtraFees,
			&i.DiscountAmount,
			&i.VatTotal,
			&i.Total,
			&i.VatNumber,
			&i.VatCompanyName,
			&i.VatReverseCharge,
			&i.VatCountryCode,
			&i.StripePaymentIntentID,
			&i.StripeCheckoutSessionID,
			&i.PaymentStatus,
			&i.DiscountID,
			&i.CouponID,
			&i.DiscountBreakdown,
			&i.ShippingMethod,
			&i.TrackingNumber,
			&i.ShippedAt,
			&i.DeliveredAt,
			&i.Notes,
			&i.CustomerNotes,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentOrders = `-- name: ListRecentOrders :many
SELECT id, order_number, email, status, payment_status, total, created_at
FROM orders ORDER BY created_at DESC LIMIT $1
`

type ListRecentOrdersRow struct {
	ID            uuid.UUID      `json:"id"`
	OrderNumber   int64          `json:"order_number"`
	Email         string         `json:"email"`
	Status        string         `json:"status"`
	PaymentStatus string         `json:"payment_status"`
	Total         pgtype.Numeric `json:"total"`
	CreatedAt     time.Time      `json:"created_at"`
}

func (q *Queries) ListRecentOrders(ctx context.Context, limit int32) ([]ListRecentOrdersRow, error) {
	rows, err := q.db.Query(ctx, listRecentOrders, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentOrdersRow{}
	for rows.Next() {
		var i ListRecentOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.Email,
			&i.Status,
			&i.PaymentStatus,
			&i.Total,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumRevenueMonth = `-- name: SumRevenueMonth :one
SELECT COALESCE(SUM(total), 0) FROM orders
WHERE created_at >= date_trunc('month', CURRENT_DATE) AND payment_status = 'paid'
`

func (q *Queries) SumRevenueMonth(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, sumRevenueMonth)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders SET status = $2, updated_at = $3 WHERE id = $1 RETURNING id, order_number, customer_id, status, email, billing_address, shipping_address, subtotal, shipping_fee, shipping_extra_fees, discount_amount, vat_total, total, vat_number, vat_company_name, vat_reverse_charge, vat_country_code, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, discount_id, coupon_id, discount_breakdown, shipping_method, tracking_number, shipped_at, delivered_at, notes, customer_notes, metadata, created_at, updated_at
`

type UpdateOrderStatusParams struct {
	ID        uuid.UUID `json:"id"`
	Status    string    `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.ID, arg.Status, arg.UpdatedAt)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.Status,
		&i.Email,
		&i.BillingAddress,
		&i.ShippingAddress,
		&i.Subtotal,
		&i.ShippingFee,
		&i.ShippingExtraFees,
		&i.DiscountAmount,
		&i.VatTotal,
		&i.Total,
		&i.VatNumber,
		&i.VatCompanyName,
		&i.VatReverseCharge,
		&i.VatCountryCode,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.DiscountID,
		&i.CouponID,
		&i.DiscountBreakdown,
		&i.ShippingMethod,
		&i.TrackingNumber,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.Notes,
		&i.CustomerNotes,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrderTracking = `-- name: UpdateOrderTracking :exec
UPDATE orders SET tracking_number = $2, shipped_at = $3, updated_at = $4 WHERE id = $1
`

type UpdateOrderTrackingParams struct {
	ID             uuid.UUID          `json:"id"`
	TrackingNumber *string            `json:"tracking_number"`
	ShippedAt      pgtype.Timestamptz `json:"shipped_at"`
	UpdatedAt      time.Time          `json:"updated_at"`
}

func (q *Queries) UpdateOrderTracking(ctx context.Context, arg UpdateOrderTrackingParams) error {
	_, err := q.db.Exec(ctx, updateOrderTracking,
		arg.ID,
		arg.TrackingNumber,
		arg.ShippedAt,
		arg.UpdatedAt,
	)
	return err
}
