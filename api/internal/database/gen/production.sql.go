// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: production.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelProductionBatch = `-- name: CancelProductionBatch :one
UPDATE production_batches
SET status = 'cancelled', updated_at = NOW()
WHERE id = $1 AND status IN ('draft', 'scheduled')
RETURNING id, batch_number, product_id, variant_id, planned_quantity, actual_quantity, status, scheduled_date, started_at, completed_at, notes, cost_total, created_by, created_at, updated_at
`

func (q *Queries) CancelProductionBatch(ctx context.Context, id uuid.UUID) (ProductionBatch, error) {
	row := q.db.QueryRow(ctx, cancelProductionBatch, id)
	var i ProductionBatch
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.ProductID,
		&i.VariantID,
		&i.PlannedQuantity,
		&i.ActualQuantity,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Notes,
		&i.CostTotal,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const completeProductionBatch = `-- name: CompleteProductionBatch :one
UPDATE production_batches
SET status = 'completed', actual_quantity = $2, completed_at = NOW(), cost_total = $3, updated_at = NOW()
WHERE id = $1 AND status = 'in_progress'
RETURNING id, batch_number, product_id, variant_id, planned_quantity, actual_quantity, status, scheduled_date, started_at, completed_at, notes, cost_total, created_by, created_at, updated_at
`

type CompleteProductionBatchParams struct {
	ID             uuid.UUID      `json:"id"`
	ActualQuantity *int32         `json:"actual_quantity"`
	CostTotal      pgtype.Numeric `json:"cost_total"`
}

func (q *Queries) CompleteProductionBatch(ctx context.Context, arg CompleteProductionBatchParams) (ProductionBatch, error) {
	row := q.db.QueryRow(ctx, completeProductionBatch, arg.ID, arg.ActualQuantity, arg.CostTotal)
	var i ProductionBatch
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.ProductID,
		&i.VariantID,
		&i.PlannedQuantity,
		&i.ActualQuantity,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Notes,
		&i.CostTotal,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countProductionBatchesByStatus = `-- name: CountProductionBatchesByStatus :one
SELECT COUNT(*) FROM production_batches WHERE status = $1
`

func (q *Queries) CountProductionBatchesByStatus(ctx context.Context, status ProductionBatchStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countProductionBatchesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBatchMaterial = `-- name: CreateBatchMaterial :one
INSERT INTO production_batch_materials (batch_id, raw_material_id, required_quantity, unit_cost)
VALUES ($1, $2, $3, $4)
RETURNING id, batch_id, raw_material_id, required_quantity, consumed_quantity, unit_cost
`

type CreateBatchMaterialParams struct {
	BatchID          uuid.UUID      `json:"batch_id"`
	RawMaterialID    uuid.UUID      `json:"raw_material_id"`
	RequiredQuantity pgtype.Numeric `json:"required_quantity"`
	UnitCost         pgtype.Numeric `json:"unit_cost"`
}

func (q *Queries) CreateBatchMaterial(ctx context.Context, arg CreateBatchMaterialParams) (ProductionBatchMaterial, error) {
	row := q.db.QueryRow(ctx, createBatchMaterial,
		arg.BatchID,
		arg.RawMaterialID,
		arg.RequiredQuantity,
		arg.UnitCost,
	)
	var i ProductionBatchMaterial
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.RawMaterialID,
		&i.RequiredQuantity,
		&i.ConsumedQuantity,
		&i.UnitCost,
	)
	return i, err
}

const createProductionBatch = `-- name: CreateProductionBatch :one
INSERT INTO production_batches (batch_number, product_id, variant_id, planned_quantity, status, scheduled_date, notes, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, batch_number, product_id, variant_id, planned_quantity, actual_quantity, status, scheduled_date, started_at, completed_at, notes, cost_total, created_by, created_at, updated_at
`

type CreateProductionBatchParams struct {
	BatchNumber     string                `json:"batch_number"`
	ProductID       uuid.UUID             `json:"product_id"`
	VariantID       pgtype.UUID           `json:"variant_id"`
	PlannedQuantity int32                 `json:"planned_quantity"`
	Status          ProductionBatchStatus `json:"status"`
	ScheduledDate   pgtype.Date           `json:"scheduled_date"`
	Notes           *string               `json:"notes"`
	CreatedBy       pgtype.UUID           `json:"created_by"`
}

func (q *Queries) CreateProductionBatch(ctx context.Context, arg CreateProductionBatchParams) (ProductionBatch, error) {
	row := q.db.QueryRow(ctx, createProductionBatch,
		arg.BatchNumber,
		arg.ProductID,
		arg.VariantID,
		arg.PlannedQuantity,
		arg.Status,
		arg.ScheduledDate,
		arg.Notes,
		arg.CreatedBy,
	)
	var i ProductionBatch
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.ProductID,
		&i.VariantID,
		&i.PlannedQuantity,
		&i.ActualQuantity,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Notes,
		&i.CostTotal,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductionBatch = `-- name: GetProductionBatch :one
SELECT pb.id, pb.batch_number, pb.product_id, pb.variant_id, pb.planned_quantity, pb.actual_quantity, pb.status, pb.scheduled_date, pb.started_at, pb.completed_at, pb.notes, pb.cost_total, pb.created_by, pb.created_at, pb.updated_at,
       p.name as product_name,
       pv.sku as variant_sku
FROM production_batches pb
JOIN products p ON p.id = pb.product_id
LEFT JOIN product_variants pv ON pv.id = pb.variant_id
WHERE pb.id = $1
`

type GetProductionBatchRow struct {
	ID              uuid.UUID             `json:"id"`
	BatchNumber     string                `json:"batch_number"`
	ProductID       uuid.UUID             `json:"product_id"`
	VariantID       pgtype.UUID           `json:"variant_id"`
	PlannedQuantity int32                 `json:"planned_quantity"`
	ActualQuantity  *int32                `json:"actual_quantity"`
	Status          ProductionBatchStatus `json:"status"`
	ScheduledDate   pgtype.Date           `json:"scheduled_date"`
	StartedAt       pgtype.Timestamptz    `json:"started_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
	Notes           *string               `json:"notes"`
	CostTotal       pgtype.Numeric        `json:"cost_total"`
	CreatedBy       pgtype.UUID           `json:"created_by"`
	CreatedAt       time.Time             `json:"created_at"`
	UpdatedAt       time.Time             `json:"updated_at"`
	ProductName     string                `json:"product_name"`
	VariantSku      *string               `json:"variant_sku"`
}

func (q *Queries) GetProductionBatch(ctx context.Context, id uuid.UUID) (GetProductionBatchRow, error) {
	row := q.db.QueryRow(ctx, getProductionBatch, id)
	var i GetProductionBatchRow
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.ProductID,
		&i.VariantID,
		&i.PlannedQuantity,
		&i.ActualQuantity,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Notes,
		&i.CostTotal,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductName,
		&i.VariantSku,
	)
	return i, err
}

const listBatchMaterials = `-- name: ListBatchMaterials :many
SELECT pbm.id, pbm.batch_id, pbm.raw_material_id, pbm.required_quantity, pbm.consumed_quantity, pbm.unit_cost, rm.name as material_name, rm.sku as material_sku, rm.unit_of_measure, rm.stock_quantity as available_stock
FROM production_batch_materials pbm
JOIN raw_materials rm ON rm.id = pbm.raw_material_id
WHERE pbm.batch_id = $1
ORDER BY rm.name
`

type ListBatchMaterialsRow struct {
	ID               uuid.UUID      `json:"id"`
	BatchID          uuid.UUID      `json:"batch_id"`
	RawMaterialID    uuid.UUID      `json:"raw_material_id"`
	RequiredQuantity pgtype.Numeric `json:"required_quantity"`
	ConsumedQuantity pgtype.Numeric `json:"consumed_quantity"`
	UnitCost         pgtype.Numeric `json:"unit_cost"`
	MaterialName     string         `json:"material_name"`
	MaterialSku      string         `json:"material_sku"`
	UnitOfMeasure    string         `json:"unit_of_measure"`
	AvailableStock   pgtype.Numeric `json:"available_stock"`
}

func (q *Queries) ListBatchMaterials(ctx context.Context, batchID uuid.UUID) ([]ListBatchMaterialsRow, error) {
	rows, err := q.db.Query(ctx, listBatchMaterials, batchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBatchMaterialsRow{}
	for rows.Next() {
		var i ListBatchMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.BatchID,
			&i.RawMaterialID,
			&i.RequiredQuantity,
			&i.ConsumedQuantity,
			&i.UnitCost,
			&i.MaterialName,
			&i.MaterialSku,
			&i.UnitOfMeasure,
			&i.AvailableStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductionBatches = `-- name: ListProductionBatches :many
SELECT pb.id, pb.batch_number, pb.product_id, pb.variant_id, pb.planned_quantity, pb.actual_quantity, pb.status, pb.scheduled_date, pb.started_at, pb.completed_at, pb.notes, pb.cost_total, pb.created_by, pb.created_at, pb.updated_at,
       p.name as product_name,
       pv.sku as variant_sku
FROM production_batches pb
JOIN products p ON p.id = pb.product_id
LEFT JOIN product_variants pv ON pv.id = pb.variant_id
ORDER BY pb.created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductionBatchesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListProductionBatchesRow struct {
	ID              uuid.UUID             `json:"id"`
	BatchNumber     string                `json:"batch_number"`
	ProductID       uuid.UUID             `json:"product_id"`
	VariantID       pgtype.UUID           `json:"variant_id"`
	PlannedQuantity int32                 `json:"planned_quantity"`
	ActualQuantity  *int32                `json:"actual_quantity"`
	Status          ProductionBatchStatus `json:"status"`
	ScheduledDate   pgtype.Date           `json:"scheduled_date"`
	StartedAt       pgtype.Timestamptz    `json:"started_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
	Notes           *string               `json:"notes"`
	CostTotal       pgtype.Numeric        `json:"cost_total"`
	CreatedBy       pgtype.UUID           `json:"created_by"`
	CreatedAt       time.Time             `json:"created_at"`
	UpdatedAt       time.Time             `json:"updated_at"`
	ProductName     string                `json:"product_name"`
	VariantSku      *string               `json:"variant_sku"`
}

func (q *Queries) ListProductionBatches(ctx context.Context, arg ListProductionBatchesParams) ([]ListProductionBatchesRow, error) {
	rows, err := q.db.Query(ctx, listProductionBatches, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProductionBatchesRow{}
	for rows.Next() {
		var i ListProductionBatchesRow
		if err := rows.Scan(
			&i.ID,
			&i.BatchNumber,
			&i.ProductID,
			&i.VariantID,
			&i.PlannedQuantity,
			&i.ActualQuantity,
			&i.Status,
			&i.ScheduledDate,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Notes,
			&i.CostTotal,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.VariantSku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductionBatchesByStatus = `-- name: ListProductionBatchesByStatus :many
SELECT pb.id, pb.batch_number, pb.product_id, pb.variant_id, pb.planned_quantity, pb.actual_quantity, pb.status, pb.scheduled_date, pb.started_at, pb.completed_at, pb.notes, pb.cost_total, pb.created_by, pb.created_at, pb.updated_at,
       p.name as product_name,
       pv.sku as variant_sku
FROM production_batches pb
JOIN products p ON p.id = pb.product_id
LEFT JOIN product_variants pv ON pv.id = pb.variant_id
WHERE pb.status = $1
ORDER BY pb.created_at DESC
`

type ListProductionBatchesByStatusRow struct {
	ID              uuid.UUID             `json:"id"`
	BatchNumber     string                `json:"batch_number"`
	ProductID       uuid.UUID             `json:"product_id"`
	VariantID       pgtype.UUID           `json:"variant_id"`
	PlannedQuantity int32                 `json:"planned_quantity"`
	ActualQuantity  *int32                `json:"actual_quantity"`
	Status          ProductionBatchStatus `json:"status"`
	ScheduledDate   pgtype.Date           `json:"scheduled_date"`
	StartedAt       pgtype.Timestamptz    `json:"started_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
	Notes           *string               `json:"notes"`
	CostTotal       pgtype.Numeric        `json:"cost_total"`
	CreatedBy       pgtype.UUID           `json:"created_by"`
	CreatedAt       time.Time             `json:"created_at"`
	UpdatedAt       time.Time             `json:"updated_at"`
	ProductName     string                `json:"product_name"`
	VariantSku      *string               `json:"variant_sku"`
}

func (q *Queries) ListProductionBatchesByStatus(ctx context.Context, status ProductionBatchStatus) ([]ListProductionBatchesByStatusRow, error) {
	rows, err := q.db.Query(ctx, listProductionBatchesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProductionBatchesByStatusRow{}
	for rows.Next() {
		var i ListProductionBatchesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.BatchNumber,
			&i.ProductID,
			&i.VariantID,
			&i.PlannedQuantity,
			&i.ActualQuantity,
			&i.Status,
			&i.ScheduledDate,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Notes,
			&i.CostTotal,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.VariantSku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextBatchNumber = `-- name: NextBatchNumber :one
SELECT COALESCE(MAX(CAST(SUBSTRING(batch_number FROM 'PB-(\d+)') AS INT)), 0) + 1 AS next_num
FROM production_batches
`

func (q *Queries) NextBatchNumber(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, nextBatchNumber)
	var next_num int32
	err := row.Scan(&next_num)
	return next_num, err
}

const startProductionBatch = `-- name: StartProductionBatch :one
UPDATE production_batches
SET status = 'in_progress', started_at = NOW(), updated_at = NOW()
WHERE id = $1 AND status IN ('draft', 'scheduled')
RETURNING id, batch_number, product_id, variant_id, planned_quantity, actual_quantity, status, scheduled_date, started_at, completed_at, notes, cost_total, created_by, created_at, updated_at
`

func (q *Queries) StartProductionBatch(ctx context.Context, id uuid.UUID) (ProductionBatch, error) {
	row := q.db.QueryRow(ctx, startProductionBatch, id)
	var i ProductionBatch
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.ProductID,
		&i.VariantID,
		&i.PlannedQuantity,
		&i.ActualQuantity,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Notes,
		&i.CostTotal,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBatchMaterialConsumed = `-- name: UpdateBatchMaterialConsumed :exec
UPDATE production_batch_materials
SET consumed_quantity = $2
WHERE id = $1
`

type UpdateBatchMaterialConsumedParams struct {
	ID               uuid.UUID      `json:"id"`
	ConsumedQuantity pgtype.Numeric `json:"consumed_quantity"`
}

func (q *Queries) UpdateBatchMaterialConsumed(ctx context.Context, arg UpdateBatchMaterialConsumedParams) error {
	_, err := q.db.Exec(ctx, updateBatchMaterialConsumed, arg.ID, arg.ConsumedQuantity)
	return err
}

const updateProductionBatchStatus = `-- name: UpdateProductionBatchStatus :one
UPDATE production_batches
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, batch_number, product_id, variant_id, planned_quantity, actual_quantity, status, scheduled_date, started_at, completed_at, notes, cost_total, created_by, created_at, updated_at
`

type UpdateProductionBatchStatusParams struct {
	ID     uuid.UUID             `json:"id"`
	Status ProductionBatchStatus `json:"status"`
}

func (q *Queries) UpdateProductionBatchStatus(ctx context.Context, arg UpdateProductionBatchStatusParams) (ProductionBatch, error) {
	row := q.db.QueryRow(ctx, updateProductionBatchStatus, arg.ID, arg.Status)
	var i ProductionBatch
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.ProductID,
		&i.VariantID,
		&i.PlannedQuantity,
		&i.ActualQuantity,
		&i.Status,
		&i.ScheduledDate,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Notes,
		&i.CostTotal,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
