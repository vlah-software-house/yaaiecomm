// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: raw_materials.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRawMaterials = `-- name: CountRawMaterials :one
SELECT COUNT(*) FROM raw_materials
WHERE ($1::uuid IS NULL OR category_id = $1)
AND ($2::bool IS NULL OR is_active = $2)
`

type CountRawMaterialsParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 bool      `json:"column_2"`
}

func (q *Queries) CountRawMaterials(ctx context.Context, arg CountRawMaterialsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRawMaterials, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRawMaterial = `-- name: CreateRawMaterial :one
INSERT INTO raw_materials (
  id, name, sku, description, category_id, unit_of_measure,
  cost_per_unit, stock_quantity, low_stock_threshold,
  supplier_name, supplier_sku, lead_time_days,
  metadata, is_active, created_at, updated_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $15)
RETURNING id, name, sku, description, category_id, unit_of_measure, cost_per_unit, stock_quantity, low_stock_threshold, supplier_name, supplier_sku, lead_time_days, metadata, is_active, created_at, updated_at
`

type CreateRawMaterialParams struct {
	ID                uuid.UUID       `json:"id"`
	Name              string          `json:"name"`
	Sku               string          `json:"sku"`
	Description       *string         `json:"description"`
	CategoryID        pgtype.UUID     `json:"category_id"`
	UnitOfMeasure     string          `json:"unit_of_measure"`
	CostPerUnit       pgtype.Numeric  `json:"cost_per_unit"`
	StockQuantity     pgtype.Numeric  `json:"stock_quantity"`
	LowStockThreshold pgtype.Numeric  `json:"low_stock_threshold"`
	SupplierName      *string         `json:"supplier_name"`
	SupplierSku       *string         `json:"supplier_sku"`
	LeadTimeDays      *int32          `json:"lead_time_days"`
	Metadata          json.RawMessage `json:"metadata"`
	IsActive          bool            `json:"is_active"`
	CreatedAt         time.Time       `json:"created_at"`
}

func (q *Queries) CreateRawMaterial(ctx context.Context, arg CreateRawMaterialParams) (RawMaterial, error) {
	row := q.db.QueryRow(ctx, createRawMaterial,
		arg.ID,
		arg.Name,
		arg.Sku,
		arg.Description,
		arg.CategoryID,
		arg.UnitOfMeasure,
		arg.CostPerUnit,
		arg.StockQuantity,
		arg.LowStockThreshold,
		arg.SupplierName,
		arg.SupplierSku,
		arg.LeadTimeDays,
		arg.Metadata,
		arg.IsActive,
		arg.CreatedAt,
	)
	var i RawMaterial
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.CategoryID,
		&i.UnitOfMeasure,
		&i.CostPerUnit,
		&i.StockQuantity,
		&i.LowStockThreshold,
		&i.SupplierName,
		&i.SupplierSku,
		&i.LeadTimeDays,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRawMaterialCategory = `-- name: CreateRawMaterialCategory :one
INSERT INTO raw_material_categories (id, name, slug, parent_id, position, created_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, slug, parent_id, position, created_at
`

type CreateRawMaterialCategoryParams struct {
	ID        uuid.UUID   `json:"id"`
	Name      string      `json:"name"`
	Slug      string      `json:"slug"`
	ParentID  pgtype.UUID `json:"parent_id"`
	Position  int32       `json:"position"`
	CreatedAt time.Time   `json:"created_at"`
}

func (q *Queries) CreateRawMaterialCategory(ctx context.Context, arg CreateRawMaterialCategoryParams) (RawMaterialCategory, error) {
	row := q.db.QueryRow(ctx, createRawMaterialCategory,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.ParentID,
		arg.Position,
		arg.CreatedAt,
	)
	var i RawMaterialCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ParentID,
		&i.Position,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRawMaterial = `-- name: DeleteRawMaterial :exec
DELETE FROM raw_materials WHERE id = $1
`

func (q *Queries) DeleteRawMaterial(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRawMaterial, id)
	return err
}

const getRawMaterial = `-- name: GetRawMaterial :one
SELECT id, name, sku, description, category_id, unit_of_measure, cost_per_unit, stock_quantity, low_stock_threshold, supplier_name, supplier_sku, lead_time_days, metadata, is_active, created_at, updated_at FROM raw_materials WHERE id = $1
`

func (q *Queries) GetRawMaterial(ctx context.Context, id uuid.UUID) (RawMaterial, error) {
	row := q.db.QueryRow(ctx, getRawMaterial, id)
	var i RawMaterial
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.CategoryID,
		&i.UnitOfMeasure,
		&i.CostPerUnit,
		&i.StockQuantity,
		&i.LowStockThreshold,
		&i.SupplierName,
		&i.SupplierSku,
		&i.LeadTimeDays,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLowStockRawMaterials = `-- name: ListLowStockRawMaterials :many
SELECT id, name, sku, description, category_id, unit_of_measure, cost_per_unit, stock_quantity, low_stock_threshold, supplier_name, supplier_sku, lead_time_days, metadata, is_active, created_at, updated_at FROM raw_materials
WHERE stock_quantity <= low_stock_threshold AND is_active = true
ORDER BY stock_quantity ASC
LIMIT $1
`

func (q *Queries) ListLowStockRawMaterials(ctx context.Context, limit int32) ([]RawMaterial, error) {
	rows, err := q.db.Query(ctx, listLowStockRawMaterials, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RawMaterial{}
	for rows.Next() {
		var i RawMaterial
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.CategoryID,
			&i.UnitOfMeasure,
			&i.CostPerUnit,
			&i.StockQuantity,
			&i.LowStockThreshold,
			&i.SupplierName,
			&i.SupplierSku,
			&i.LeadTimeDays,
			&i.Metadata,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRawMaterialCategories = `-- name: ListRawMaterialCategories :many
SELECT id, name, slug, parent_id, position, created_at FROM raw_material_categories ORDER BY position, name
`

func (q *Queries) ListRawMaterialCategories(ctx context.Context) ([]RawMaterialCategory, error) {
	rows, err := q.db.Query(ctx, listRawMaterialCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RawMaterialCategory{}
	for rows.Next() {
		var i RawMaterialCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ParentID,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRawMaterials = `-- name: ListRawMaterials :many
SELECT id, name, sku, description, category_id, unit_of_measure, cost_per_unit, stock_quantity, low_stock_threshold, supplier_name, supplier_sku, lead_time_days, metadata, is_active, created_at, updated_at FROM raw_materials
WHERE ($1::uuid IS NULL OR category_id = $1)
AND ($2::bool IS NULL OR is_active = $2)
ORDER BY name
LIMIT $3 OFFSET $4
`

type ListRawMaterialsParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 bool      `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListRawMaterials(ctx context.Context, arg ListRawMaterialsParams) ([]RawMaterial, error) {
	rows, err := q.db.Query(ctx, listRawMaterials,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RawMaterial{}
	for rows.Next() {
		var i RawMaterial
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.CategoryID,
			&i.UnitOfMeasure,
			&i.CostPerUnit,
			&i.StockQuantity,
			&i.LowStockThreshold,
			&i.SupplierName,
			&i.SupplierSku,
			&i.LeadTimeDays,
			&i.Metadata,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRawMaterials = `-- name: SearchRawMaterials :many
SELECT id, name, sku, description, category_id, unit_of_measure, cost_per_unit, stock_quantity, low_stock_threshold, supplier_name, supplier_sku, lead_time_days, metadata, is_active, created_at, updated_at FROM raw_materials
WHERE (name ILIKE '%' || $1 || '%' OR sku ILIKE '%' || $1 || '%')
ORDER BY name
LIMIT $2 OFFSET $3
`

type SearchRawMaterialsParams struct {
	Column1 *string `json:"column_1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) SearchRawMaterials(ctx context.Context, arg SearchRawMaterialsParams) ([]RawMaterial, error) {
	rows, err := q.db.Query(ctx, searchRawMaterials, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RawMaterial{}
	for rows.Next() {
		var i RawMaterial
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.CategoryID,
			&i.UnitOfMeasure,
			&i.CostPerUnit,
			&i.StockQuantity,
			&i.LowStockThreshold,
			&i.SupplierName,
			&i.SupplierSku,
			&i.LeadTimeDays,
			&i.Metadata,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRawMaterial = `-- name: UpdateRawMaterial :one
UPDATE raw_materials SET
  name = $2, sku = $3, description = $4, category_id = $5,
  unit_of_measure = $6, cost_per_unit = $7, stock_quantity = $8,
  low_stock_threshold = $9, supplier_name = $10, supplier_sku = $11,
  lead_time_days = $12, metadata = $13, is_active = $14, updated_at = $15
WHERE id = $1
RETURNING id, name, sku, description, category_id, unit_of_measure, cost_per_unit, stock_quantity, low_stock_threshold, supplier_name, supplier_sku, lead_time_days, metadata, is_active, created_at, updated_at
`

type UpdateRawMaterialParams struct {
	ID                uuid.UUID       `json:"id"`
	Name              string          `json:"name"`
	Sku               string          `json:"sku"`
	Description       *string         `json:"description"`
	CategoryID        pgtype.UUID     `json:"category_id"`
	UnitOfMeasure     string          `json:"unit_of_measure"`
	CostPerUnit       pgtype.Numeric  `json:"cost_per_unit"`
	StockQuantity     pgtype.Numeric  `json:"stock_quantity"`
	LowStockThreshold pgtype.Numeric  `json:"low_stock_threshold"`
	SupplierName      *string         `json:"supplier_name"`
	SupplierSku       *string         `json:"supplier_sku"`
	LeadTimeDays      *int32          `json:"lead_time_days"`
	Metadata          json.RawMessage `json:"metadata"`
	IsActive          bool            `json:"is_active"`
	UpdatedAt         time.Time       `json:"updated_at"`
}

func (q *Queries) UpdateRawMaterial(ctx context.Context, arg UpdateRawMaterialParams) (RawMaterial, error) {
	row := q.db.QueryRow(ctx, updateRawMaterial,
		arg.ID,
		arg.Name,
		arg.Sku,
		arg.Description,
		arg.CategoryID,
		arg.UnitOfMeasure,
		arg.CostPerUnit,
		arg.StockQuantity,
		arg.LowStockThreshold,
		arg.SupplierName,
		arg.SupplierSku,
		arg.LeadTimeDays,
		arg.Metadata,
		arg.IsActive,
		arg.UpdatedAt,
	)
	var i RawMaterial
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.CategoryID,
		&i.UnitOfMeasure,
		&i.CostPerUnit,
		&i.StockQuantity,
		&i.LowStockThreshold,
		&i.SupplierName,
		&i.SupplierSku,
		&i.LeadTimeDays,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
