// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reports.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const salesReportDaily = `-- name: SalesReportDaily :many
SELECT
  DATE(created_at) as report_date,
  COUNT(*) as order_count,
  COALESCE(SUM(subtotal), 0) as net_revenue,
  COALESCE(SUM(vat_total), 0) as vat_collected,
  COALESCE(SUM(total), 0) as gross_revenue,
  COALESCE(SUM(discount_amount), 0) as total_discounts
FROM orders
WHERE payment_status = 'paid'
  AND created_at >= $1
  AND created_at < $2
GROUP BY DATE(created_at)
ORDER BY report_date
`

type SalesReportDailyParams struct {
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type SalesReportDailyRow struct {
	ReportDate     pgtype.Date `json:"report_date"`
	OrderCount     int64       `json:"order_count"`
	NetRevenue     interface{} `json:"net_revenue"`
	VatCollected   interface{} `json:"vat_collected"`
	GrossRevenue   interface{} `json:"gross_revenue"`
	TotalDiscounts interface{} `json:"total_discounts"`
}

// Daily sales aggregation for a date range.
func (q *Queries) SalesReportDaily(ctx context.Context, arg SalesReportDailyParams) ([]SalesReportDailyRow, error) {
	rows, err := q.db.Query(ctx, salesReportDaily, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SalesReportDailyRow{}
	for rows.Next() {
		var i SalesReportDailyRow
		if err := rows.Scan(
			&i.ReportDate,
			&i.OrderCount,
			&i.NetRevenue,
			&i.VatCollected,
			&i.GrossRevenue,
			&i.TotalDiscounts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const salesReportSummary = `-- name: SalesReportSummary :one
SELECT
  COUNT(*) as order_count,
  COALESCE(SUM(subtotal), 0) as net_revenue,
  COALESCE(SUM(vat_total), 0) as vat_collected,
  COALESCE(SUM(total), 0) as gross_revenue,
  COALESCE(SUM(discount_amount), 0) as total_discounts,
  CASE WHEN COUNT(*) > 0 THEN ROUND(COALESCE(SUM(total), 0) / COUNT(*), 2) ELSE 0 END::NUMERIC(12,2) as average_order_value
FROM orders
WHERE payment_status = 'paid'
  AND created_at >= $1
  AND created_at < $2
`

type SalesReportSummaryParams struct {
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type SalesReportSummaryRow struct {
	OrderCount        int64          `json:"order_count"`
	NetRevenue        interface{}    `json:"net_revenue"`
	VatCollected      interface{}    `json:"vat_collected"`
	GrossRevenue      interface{}    `json:"gross_revenue"`
	TotalDiscounts    interface{}    `json:"total_discounts"`
	AverageOrderValue pgtype.Numeric `json:"average_order_value"`
}

// Summary metrics for a period.
func (q *Queries) SalesReportSummary(ctx context.Context, arg SalesReportSummaryParams) (SalesReportSummaryRow, error) {
	row := q.db.QueryRow(ctx, salesReportSummary, arg.FromDate, arg.ToDate)
	var i SalesReportSummaryRow
	err := row.Scan(
		&i.OrderCount,
		&i.NetRevenue,
		&i.VatCollected,
		&i.GrossRevenue,
		&i.TotalDiscounts,
		&i.AverageOrderValue,
	)
	return i, err
}

const topProductsByRevenue = `-- name: TopProductsByRevenue :many
SELECT
  oi.product_name,
  SUM(oi.quantity)::bigint as total_quantity,
  COALESCE(SUM(oi.total_price), 0) as total_revenue
FROM order_items oi
JOIN orders o ON o.id = oi.order_id
WHERE o.payment_status = 'paid'
  AND o.created_at >= $1
  AND o.created_at < $2
GROUP BY oi.product_name
ORDER BY total_revenue DESC
LIMIT $3
`

type TopProductsByRevenueParams struct {
	FromDate   time.Time `json:"from_date"`
	ToDate     time.Time `json:"to_date"`
	MaxResults int32     `json:"max_results"`
}

type TopProductsByRevenueRow struct {
	ProductName   string      `json:"product_name"`
	TotalQuantity int64       `json:"total_quantity"`
	TotalRevenue  interface{} `json:"total_revenue"`
}

// Top selling products by revenue for a period.
func (q *Queries) TopProductsByRevenue(ctx context.Context, arg TopProductsByRevenueParams) ([]TopProductsByRevenueRow, error) {
	rows, err := q.db.Query(ctx, topProductsByRevenue, arg.FromDate, arg.ToDate, arg.MaxResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TopProductsByRevenueRow{}
	for rows.Next() {
		var i TopProductsByRevenueRow
		if err := rows.Scan(&i.ProductName, &i.TotalQuantity, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vATReportByCountry = `-- name: VATReportByCountry :many
SELECT
  o.vat_country_code as country_code,
  ec.name as country_name,
  oi.vat_rate_type as rate_type,
  oi.vat_rate as rate,
  COALESCE(SUM(oi.net_unit_price * oi.quantity), 0) as net_sales,
  COALESCE(SUM(oi.vat_amount), 0) as vat_collected,
  COALESCE(SUM(oi.gross_unit_price * oi.quantity), 0) as gross_sales,
  COUNT(DISTINCT o.id) as order_count
FROM orders o
JOIN order_items oi ON oi.order_id = o.id
LEFT JOIN eu_countries ec ON ec.country_code = o.vat_country_code
WHERE o.payment_status = 'paid'
  AND o.vat_reverse_charge = false
  AND o.created_at >= $1
  AND o.created_at < $2
GROUP BY o.vat_country_code, ec.name, oi.vat_rate_type, oi.vat_rate
ORDER BY o.vat_country_code, oi.vat_rate_type
`

type VATReportByCountryParams struct {
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type VATReportByCountryRow struct {
	CountryCode  *string        `json:"country_code"`
	CountryName  *string        `json:"country_name"`
	RateType     *string        `json:"rate_type"`
	Rate         pgtype.Numeric `json:"rate"`
	NetSales     interface{}    `json:"net_sales"`
	VatCollected interface{}    `json:"vat_collected"`
	GrossSales   interface{}    `json:"gross_sales"`
	OrderCount   int64          `json:"order_count"`
}

// VAT collected per country per rate type for a period.
func (q *Queries) VATReportByCountry(ctx context.Context, arg VATReportByCountryParams) ([]VATReportByCountryRow, error) {
	rows, err := q.db.Query(ctx, vATReportByCountry, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VATReportByCountryRow{}
	for rows.Next() {
		var i VATReportByCountryRow
		if err := rows.Scan(
			&i.CountryCode,
			&i.CountryName,
			&i.RateType,
			&i.Rate,
			&i.NetSales,
			&i.VatCollected,
			&i.GrossSales,
			&i.OrderCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vATReverseChargeReport = `-- name: VATReverseChargeReport :many
SELECT
  o.id,
  o.order_number,
  o.email,
  o.vat_number,
  o.vat_company_name,
  o.vat_country_code,
  o.subtotal as net_total,
  o.created_at
FROM orders o
WHERE o.payment_status = 'paid'
  AND o.vat_reverse_charge = true
  AND o.created_at >= $1
  AND o.created_at < $2
ORDER BY o.created_at DESC
`

type VATReverseChargeReportParams struct {
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type VATReverseChargeReportRow struct {
	ID             uuid.UUID      `json:"id"`
	OrderNumber    int64          `json:"order_number"`
	Email          string         `json:"email"`
	VatNumber      *string        `json:"vat_number"`
	VatCompanyName *string        `json:"vat_company_name"`
	VatCountryCode *string        `json:"vat_country_code"`
	NetTotal       pgtype.Numeric `json:"net_total"`
	CreatedAt      time.Time      `json:"created_at"`
}

// B2B reverse charge orders for a period.
func (q *Queries) VATReverseChargeReport(ctx context.Context, arg VATReverseChargeReportParams) ([]VATReverseChargeReportRow, error) {
	rows, err := q.db.Query(ctx, vATReverseChargeReport, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VATReverseChargeReportRow{}
	for rows.Next() {
		var i VATReverseChargeReportRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.Email,
			&i.VatNumber,
			&i.VatCompanyName,
			&i.VatCountryCode,
			&i.NetTotal,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vATReverseChargeSummary = `-- name: VATReverseChargeSummary :one
SELECT
  COUNT(*) as order_count,
  COALESCE(SUM(subtotal), 0) as total_net
FROM orders
WHERE payment_status = 'paid'
  AND vat_reverse_charge = true
  AND created_at >= $1
  AND created_at < $2
`

type VATReverseChargeSummaryParams struct {
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type VATReverseChargeSummaryRow struct {
	OrderCount int64       `json:"order_count"`
	TotalNet   interface{} `json:"total_net"`
}

// Summary of B2B reverse charge for a period.
func (q *Queries) VATReverseChargeSummary(ctx context.Context, arg VATReverseChargeSummaryParams) (VATReverseChargeSummaryRow, error) {
	row := q.db.QueryRow(ctx, vATReverseChargeSummary, arg.FromDate, arg.ToDate)
	var i VATReverseChargeSummaryRow
	err := row.Scan(&i.OrderCount, &i.TotalNet)
	return i, err
}
