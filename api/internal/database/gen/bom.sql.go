// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bom.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOptionBOMEntry = `-- name: CreateOptionBOMEntry :one
INSERT INTO attribute_option_bom_entries (id, option_id, raw_material_id, quantity, unit_of_measure, notes)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, option_id, raw_material_id, quantity, unit_of_measure, notes, created_at
`

type CreateOptionBOMEntryParams struct {
	ID            uuid.UUID      `json:"id"`
	OptionID      uuid.UUID      `json:"option_id"`
	RawMaterialID uuid.UUID      `json:"raw_material_id"`
	Quantity      pgtype.Numeric `json:"quantity"`
	UnitOfMeasure string         `json:"unit_of_measure"`
	Notes         *string        `json:"notes"`
}

func (q *Queries) CreateOptionBOMEntry(ctx context.Context, arg CreateOptionBOMEntryParams) (AttributeOptionBomEntry, error) {
	row := q.db.QueryRow(ctx, createOptionBOMEntry,
		arg.ID,
		arg.OptionID,
		arg.RawMaterialID,
		arg.Quantity,
		arg.UnitOfMeasure,
		arg.Notes,
	)
	var i AttributeOptionBomEntry
	err := row.Scan(
		&i.ID,
		&i.OptionID,
		&i.RawMaterialID,
		&i.Quantity,
		&i.UnitOfMeasure,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createOptionBOMModifier = `-- name: CreateOptionBOMModifier :one
INSERT INTO attribute_option_bom_modifiers (id, option_id, product_bom_entry_id, modifier_type, modifier_value, notes)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, option_id, product_bom_entry_id, modifier_type, modifier_value, notes, created_at
`

type CreateOptionBOMModifierParams struct {
	ID                uuid.UUID      `json:"id"`
	OptionID          uuid.UUID      `json:"option_id"`
	ProductBomEntryID uuid.UUID      `json:"product_bom_entry_id"`
	ModifierType      string         `json:"modifier_type"`
	ModifierValue     pgtype.Numeric `json:"modifier_value"`
	Notes             *string        `json:"notes"`
}

func (q *Queries) CreateOptionBOMModifier(ctx context.Context, arg CreateOptionBOMModifierParams) (AttributeOptionBomModifier, error) {
	row := q.db.QueryRow(ctx, createOptionBOMModifier,
		arg.ID,
		arg.OptionID,
		arg.ProductBomEntryID,
		arg.ModifierType,
		arg.ModifierValue,
		arg.Notes,
	)
	var i AttributeOptionBomModifier
	err := row.Scan(
		&i.ID,
		&i.OptionID,
		&i.ProductBomEntryID,
		&i.ModifierType,
		&i.ModifierValue,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createProductBOMEntry = `-- name: CreateProductBOMEntry :one
INSERT INTO product_bom_entries (id, product_id, raw_material_id, quantity, unit_of_measure, is_required, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, product_id, raw_material_id, quantity, unit_of_measure, is_required, notes, created_at
`

type CreateProductBOMEntryParams struct {
	ID            uuid.UUID      `json:"id"`
	ProductID     uuid.UUID      `json:"product_id"`
	RawMaterialID uuid.UUID      `json:"raw_material_id"`
	Quantity      pgtype.Numeric `json:"quantity"`
	UnitOfMeasure string         `json:"unit_of_measure"`
	IsRequired    bool           `json:"is_required"`
	Notes         *string        `json:"notes"`
}

func (q *Queries) CreateProductBOMEntry(ctx context.Context, arg CreateProductBOMEntryParams) (ProductBomEntry, error) {
	row := q.db.QueryRow(ctx, createProductBOMEntry,
		arg.ID,
		arg.ProductID,
		arg.RawMaterialID,
		arg.Quantity,
		arg.UnitOfMeasure,
		arg.IsRequired,
		arg.Notes,
	)
	var i ProductBomEntry
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.RawMaterialID,
		&i.Quantity,
		&i.UnitOfMeasure,
		&i.IsRequired,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createVariantBOMOverride = `-- name: CreateVariantBOMOverride :one
INSERT INTO variant_bom_overrides (id, variant_id, raw_material_id, override_type, replaces_material_id, quantity, unit_of_measure, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, variant_id, raw_material_id, override_type, replaces_material_id, quantity, unit_of_measure, notes, created_at
`

type CreateVariantBOMOverrideParams struct {
	ID                 uuid.UUID      `json:"id"`
	VariantID          uuid.UUID      `json:"variant_id"`
	RawMaterialID      uuid.UUID      `json:"raw_material_id"`
	OverrideType       string         `json:"override_type"`
	ReplacesMaterialID pgtype.UUID    `json:"replaces_material_id"`
	Quantity           pgtype.Numeric `json:"quantity"`
	UnitOfMeasure      *string        `json:"unit_of_measure"`
	Notes              *string        `json:"notes"`
}

func (q *Queries) CreateVariantBOMOverride(ctx context.Context, arg CreateVariantBOMOverrideParams) (VariantBomOverride, error) {
	row := q.db.QueryRow(ctx, createVariantBOMOverride,
		arg.ID,
		arg.VariantID,
		arg.RawMaterialID,
		arg.OverrideType,
		arg.ReplacesMaterialID,
		arg.Quantity,
		arg.UnitOfMeasure,
		arg.Notes,
	)
	var i VariantBomOverride
	err := row.Scan(
		&i.ID,
		&i.VariantID,
		&i.RawMaterialID,
		&i.OverrideType,
		&i.ReplacesMaterialID,
		&i.Quantity,
		&i.UnitOfMeasure,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOptionBOMEntry = `-- name: DeleteOptionBOMEntry :exec
DELETE FROM attribute_option_bom_entries WHERE id = $1
`

func (q *Queries) DeleteOptionBOMEntry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOptionBOMEntry, id)
	return err
}

const deleteOptionBOMModifier = `-- name: DeleteOptionBOMModifier :exec
DELETE FROM attribute_option_bom_modifiers WHERE id = $1
`

func (q *Queries) DeleteOptionBOMModifier(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOptionBOMModifier, id)
	return err
}

const deleteProductBOMEntry = `-- name: DeleteProductBOMEntry :exec
DELETE FROM product_bom_entries WHERE id = $1
`

func (q *Queries) DeleteProductBOMEntry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductBOMEntry, id)
	return err
}

const deleteVariantBOMOverride = `-- name: DeleteVariantBOMOverride :exec
DELETE FROM variant_bom_overrides WHERE id = $1
`

func (q *Queries) DeleteVariantBOMOverride(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVariantBOMOverride, id)
	return err
}

const listOptionBOMEntries = `-- name: ListOptionBOMEntries :many
SELECT aobe.id, aobe.option_id, aobe.raw_material_id, aobe.quantity, aobe.unit_of_measure, aobe.notes, aobe.created_at, rm.name as material_name, rm.sku as material_sku
FROM attribute_option_bom_entries aobe
JOIN raw_materials rm ON rm.id = aobe.raw_material_id
WHERE aobe.option_id = $1
ORDER BY rm.name
`

type ListOptionBOMEntriesRow struct {
	ID            uuid.UUID      `json:"id"`
	OptionID      uuid.UUID      `json:"option_id"`
	RawMaterialID uuid.UUID      `json:"raw_material_id"`
	Quantity      pgtype.Numeric `json:"quantity"`
	UnitOfMeasure string         `json:"unit_of_measure"`
	Notes         *string        `json:"notes"`
	CreatedAt     time.Time      `json:"created_at"`
	MaterialName  string         `json:"material_name"`
	MaterialSku   string         `json:"material_sku"`
}

func (q *Queries) ListOptionBOMEntries(ctx context.Context, optionID uuid.UUID) ([]ListOptionBOMEntriesRow, error) {
	rows, err := q.db.Query(ctx, listOptionBOMEntries, optionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionBOMEntriesRow{}
	for rows.Next() {
		var i ListOptionBOMEntriesRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionID,
			&i.RawMaterialID,
			&i.Quantity,
			&i.UnitOfMeasure,
			&i.Notes,
			&i.CreatedAt,
			&i.MaterialName,
			&i.MaterialSku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionBOMModifiers = `-- name: ListOptionBOMModifiers :many
SELECT aobm.id, aobm.option_id, aobm.product_bom_entry_id, aobm.modifier_type, aobm.modifier_value, aobm.notes, aobm.created_at, rm.name as material_name
FROM attribute_option_bom_modifiers aobm
JOIN product_bom_entries pbe ON pbe.id = aobm.product_bom_entry_id
JOIN raw_materials rm ON rm.id = pbe.raw_material_id
WHERE aobm.option_id = $1
ORDER BY rm.name
`

type ListOptionBOMModifiersRow struct {
	ID                uuid.UUID      `json:"id"`
	OptionID          uuid.UUID      `json:"option_id"`
	ProductBomEntryID uuid.UUID      `json:"product_bom_entry_id"`
	ModifierType      string         `json:"modifier_type"`
	ModifierValue     pgtype.Numeric `json:"modifier_value"`
	Notes             *string        `json:"notes"`
	CreatedAt         time.Time      `json:"created_at"`
	MaterialName      string         `json:"material_name"`
}

func (q *Queries) ListOptionBOMModifiers(ctx context.Context, optionID uuid.UUID) ([]ListOptionBOMModifiersRow, error) {
	rows, err := q.db.Query(ctx, listOptionBOMModifiers, optionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionBOMModifiersRow{}
	for rows.Next() {
		var i ListOptionBOMModifiersRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionID,
			&i.ProductBomEntryID,
			&i.ModifierType,
			&i.ModifierValue,
			&i.Notes,
			&i.CreatedAt,
			&i.MaterialName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductBOMEntries = `-- name: ListProductBOMEntries :many
SELECT pbe.id, pbe.product_id, pbe.raw_material_id, pbe.quantity, pbe.unit_of_measure, pbe.is_required, pbe.notes, pbe.created_at, rm.name as material_name, rm.sku as material_sku, rm.unit_of_measure
FROM product_bom_entries pbe
JOIN raw_materials rm ON rm.id = pbe.raw_material_id
WHERE pbe.product_id = $1
ORDER BY rm.name
`

type ListProductBOMEntriesRow struct {
	ID              uuid.UUID      `json:"id"`
	ProductID       uuid.UUID      `json:"product_id"`
	RawMaterialID   uuid.UUID      `json:"raw_material_id"`
	Quantity        pgtype.Numeric `json:"quantity"`
	UnitOfMeasure   string         `json:"unit_of_measure"`
	IsRequired      bool           `json:"is_required"`
	Notes           *string        `json:"notes"`
	CreatedAt       time.Time      `json:"created_at"`
	MaterialName    string         `json:"material_name"`
	MaterialSku     string         `json:"material_sku"`
	UnitOfMeasure_2 string         `json:"unit_of_measure_2"`
}

func (q *Queries) ListProductBOMEntries(ctx context.Context, productID uuid.UUID) ([]ListProductBOMEntriesRow, error) {
	rows, err := q.db.Query(ctx, listProductBOMEntries, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProductBOMEntriesRow{}
	for rows.Next() {
		var i ListProductBOMEntriesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.RawMaterialID,
			&i.Quantity,
			&i.UnitOfMeasure,
			&i.IsRequired,
			&i.Notes,
			&i.CreatedAt,
			&i.MaterialName,
			&i.MaterialSku,
			&i.UnitOfMeasure_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVariantBOMOverrides = `-- name: ListVariantBOMOverrides :many
SELECT vbo.id, vbo.variant_id, vbo.raw_material_id, vbo.override_type, vbo.replaces_material_id, vbo.quantity, vbo.unit_of_measure, vbo.notes, vbo.created_at, rm.name as material_name, rm2.name as replaces_material_name
FROM variant_bom_overrides vbo
JOIN raw_materials rm ON rm.id = vbo.raw_material_id
LEFT JOIN raw_materials rm2 ON rm2.id = vbo.replaces_material_id
WHERE vbo.variant_id = $1
ORDER BY rm.name
`

type ListVariantBOMOverridesRow struct {
	ID                   uuid.UUID      `json:"id"`
	VariantID            uuid.UUID      `json:"variant_id"`
	RawMaterialID        uuid.UUID      `json:"raw_material_id"`
	OverrideType         string         `json:"override_type"`
	ReplacesMaterialID   pgtype.UUID    `json:"replaces_material_id"`
	Quantity             pgtype.Numeric `json:"quantity"`
	UnitOfMeasure        *string        `json:"unit_of_measure"`
	Notes                *string        `json:"notes"`
	CreatedAt            time.Time      `json:"created_at"`
	MaterialName         string         `json:"material_name"`
	ReplacesMaterialName *string        `json:"replaces_material_name"`
}

func (q *Queries) ListVariantBOMOverrides(ctx context.Context, variantID uuid.UUID) ([]ListVariantBOMOverridesRow, error) {
	rows, err := q.db.Query(ctx, listVariantBOMOverrides, variantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVariantBOMOverridesRow{}
	for rows.Next() {
		var i ListVariantBOMOverridesRow
		if err := rows.Scan(
			&i.ID,
			&i.VariantID,
			&i.RawMaterialID,
			&i.OverrideType,
			&i.ReplacesMaterialID,
			&i.Quantity,
			&i.UnitOfMeasure,
			&i.Notes,
			&i.CreatedAt,
			&i.MaterialName,
			&i.ReplacesMaterialName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductBOMEntry = `-- name: UpdateProductBOMEntry :one
UPDATE product_bom_entries SET quantity = $2, unit_of_measure = $3, is_required = $4, notes = $5
WHERE id = $1
RETURNING id, product_id, raw_material_id, quantity, unit_of_measure, is_required, notes, created_at
`

type UpdateProductBOMEntryParams struct {
	ID            uuid.UUID      `json:"id"`
	Quantity      pgtype.Numeric `json:"quantity"`
	UnitOfMeasure string         `json:"unit_of_measure"`
	IsRequired    bool           `json:"is_required"`
	Notes         *string        `json:"notes"`
}

func (q *Queries) UpdateProductBOMEntry(ctx context.Context, arg UpdateProductBOMEntryParams) (ProductBomEntry, error) {
	row := q.db.QueryRow(ctx, updateProductBOMEntry,
		arg.ID,
		arg.Quantity,
		arg.UnitOfMeasure,
		arg.IsRequired,
		arg.Notes,
	)
	var i ProductBomEntry
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.RawMaterialID,
		&i.Quantity,
		&i.UnitOfMeasure,
		&i.IsRequired,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}
